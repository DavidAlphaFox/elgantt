* Lexical binding
#+begin_src emacs-lisp :results silent
  ;;; -*- lexical-binding: t; -*-
#+end_src
* Requirements
#+begin_src emacs-lisp :results silent
(require 'cl-lib)
(require 'color)
(require 'org)
(require 'org-ql)
(require 's)
(require 'dash)
(require 'ts)
(require 'ov)
#+end_src
* Faces
#+begin_src emacs-lisp :results silent
  ;; I know you're not supposed to end face names in "-face"

  (defface elgantt-interaction::message-bar-face '((t (:background "gray" :foreground "black")))
    "Message bar face.")

  (defface elg:horizontal-line-face
    '((t :background "white" :foreground "white" :height .1))
    "Horizontal line face")

  (defface elg:vertical-line-face
    '((t :background "white" :foreground "white" :height .1))
    "Vertical line face")

  (defface elg:dependent-highlight
    '((t (:background "white" :foreground "white")))
    "dependent highlight face")

  (defface elg-header-line-face '((t (:background "black")))
    "Header line face.")

  ;; (defun elgnatt:set-vertical-bar-face ()
  ;;   (goto-char (point-min))
  ;;   (while (re-search-forward elg:vertical-line-char nil t)
  ;;     (put-text-property (match-beginning 0)
  ;; 		       (match-end 0)
  ;; 		       'face
  ;; 		       'elg-vertical-line-face)))
#+end_src
* Constants
** Layout variables
#+begin_src emacs-lisp :results silent
(defconst elg:leap-year-month-line   "| January xxxx                  | February xxxx               | March xxxx                    | April xxxx                   | May xxxx                      | June xxxx                    | July xxxx                     | August xxxx                   | September xxxx               | October xxxx                  | November xxxx                | December xxxx                 ")
(defconst elg:leap-year-date-line    "|1234567890123456789012345678901|12345678901234567890123456789|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901")
(defconst elg:leap-year-blank-line   "|                               |                             |                               |                              |                               |                              |                               |                               |                              |                               |                              |                               ")
(defconst elg:normal-year-month-line "| January xxxx                  | February xxxx              | March xxxx                    | April xxxx                   | May xxxx                      | June xxxx                    | July xxxx                     | August xxxx                   | September xxxx               | October xxxx                  | November xxxx                | December xxxx                 ")
(defconst elg:normal-year-date-line  "|1234567890123456789012345678901|1234567890123456789012345678|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901")
(defconst elg:normal-year-blank-line "|                               |                            |                               |                              |                               |                              |                               |                               |                              |                               |                              |                               ")
(defconst elg:vertical-line-char "|")

(put-text-property 0 1 'face 'elg:vertical-line-face elg:vertical-line-char)

(defmacro elg::add-vertical-line-props (lines)
  (let ((body (cl-loop for line in lines
		       collect `(setq ,line (s-replace "|" ,elg:vertical-line-char ,line)))))
    `(progn ,@body)))

(elg::add-vertical-line-props (elg:leap-year-month-line
				   elg:leap-year-date-line
				   elg:leap-year-blank-line
				   elg:normal-year-month-line
				   elg:normal-year-date-line
				   elg:normal-year-blank-line))
#+end_src 
* Private variables
** Parsing functions
#+begin_src emacs-lisp :results silent
    (defvar elg--parsing-functions nil
      "List of functions for parsing org files.")
#+end_src
** display rules
#+begin_src emacs-lisp :results silent
  (defvar elg--display-rules nil
    "List of functions for drawing overlays in the buffer based on underlying text properties.")
#+end_src
** Date range
#+begin_src emacs-lisp :results silent 
  (defvar elg::date-range nil
    "Range of years present in the agenda files.")
#+end_src
* Custom variables
** Timestamps to display
#+begin_src emacs-lisp
(defcustom elg-timestamps-to-display '(deadline timestamp timestamp-ia scheduled timestamp-range timestamp-ia-range)
  "List of the types of timestamps to display in the calendar. Order matters! If an entry has two types of 
timestamps, then the first found will be used to determine where it appears in the calendar.")
#+end_src

#+RESULTS:
: elg-timestamps-to-display

** Display characters
#+begin_src emacs-lisp :results silent
  (defcustom elg-cal-deadline-character "▲"
    "Character used for deadlines in the calendar.")
  (defcustom elg-cal-active-timestamp-character "●"
    "Character used for active timestamps in the calendar")
  (defcustom elg-cal-inactive-timestamp-character "⊚"
    "Character used for inactive timestamps in the calendar")
  (defcustom elg-cal-scheduled-character "⬟"
    "Character used for active timestamps in the calendar")
  (defcustom elg-cal-multiple-entry-character "☰"
    "Character used for cells which have multiple entries")
  (defcustom elg-cal-timestamp-range-start-character "▶"
    "Character shown at the beginning of a timerange.")
  (defcustom elg-cal-timestamp-range-end-character "◀"
    "Character shown at the end of a timerange.")
  (defvar elg:cell-entry-re (concat "["
                                    elg-cal-deadline-character
                                    elg-cal-active-timestamp-character
                                    elg-cal-inactive-timestamp-character
                                    elg-cal-scheduled-character
                                    elg-cal-multiple-entry-character
                                    elg-cal-timestamp-range-end-character
                                    elg-cal-timestamp-range-start-character
                                    "]") 
    "List of display characters for use as a regexp.")
#+end_src 
** Agenda file customization
#+begin_src emacs-lisp :results silent
(defcustom elg:agenda-files (org-agenda-files)
  "Source org files. Default: `org-agenda-files'.")

(setq elg:agenda-files "~/.emacs.d/lisp/elgantt/TEST/sample.org")
(setq elg:agenda-files "~/.emacs.d/lisp/elgantt/TEST/sample-work.org")
;;(setq elg:agenda-files "~/Dropbox/DropsyncFiles/taskmaster.org")

(defcustom elg:skip-files 'archive
  "Accepts the following values from `org-map-entries'):
`archive'    skip trees with the archive tag
`comment'    skip trees with the COMMENT keyword
`function' or Emacs Lisp form:
           will be used as value for org-agenda-skip-function, so
           whenever the function returns a position, FUNC will not be
           called for that entry and search will continue from the
           position returned")
#+end_src
** Start date
#+begin_src emacs-lisp :results silent 
(defcustom elg:start-year 2020
  "Beginning year for the calendar; nothing before Jan. 1 of this year will be shown.")
#+end_src
** Header column offset
#+begin_src emacs-lisp :results silent
  (defcustom elg:header-column-offset 20
    "Width of the header column") 
#+end_src
** Header type
#+begin_src emacs-lisp :results silent
(defcustom elg:header-type 'root
  "Define how to gather the headers. Values are root, category, hashtag, 
or a function that returns the desired header.")
#+end_src
** Header line format 
#+begin_src emacs-lisp :results silent
    (defcustom elg-header-line-format
          '(:eval
            (let ((string (s-pad-right (window-total-width) " "
                                       (concat (when (elg:get-date-at-point)
                                                 (s-pad-right 30 " " (elg:get-date-at-point)))
                                               (when (elg:get-header-at-point)
                                                 (s-pad-right 30 " " (elg:get-header-at-point)))
                                               (when-let ((headlines (elg:get-prop-at-point :elg-headline)))
                                                 (if (> (length headlines) 1)
                                                     (cl-loop for headline in headlines
                                                              concat (concat headline " / "))
                                                   (concat (car headlines))))))))
              (put-text-property 0 (length string) 'face 'elg-header-line-face string)
              string))
          "Header line format variable. See `header-line-format'.")
#+end_src 
** Warning days for deadlines
#+begin_src emacs-lisp
  (defcustom elg::deadline-warning-days org-deadline-warning-days
    "Warning days to show in calendar.")
#+end_src

#+RESULTS:
: elg::deadline-warning-days

* Utility functions
** List utilities
*** elg--change-symbol
#+begin_src emacs-lisp :results silent
  (defun elg--change-symbol (symbol &optional prefix suffix)
    (intern (concat prefix (symbol-name symbol) suffix)))
#+end_src
*** Colonizer
#+begin_src emacs-lisp  :results silent
  (defun elg--colonizer (prop &optional remove)
    "PROP is a symbol with or without a colon prefix. 
  Returns a symbol with a colon prefix. If REMOVE is t, 
  then return a symbol without a colon prefix.

  Useful for parsing user-supplied property names."
    (if remove
        (if (s-starts-with-p ":" (symbol-name prop))
            (intern (substring (symbol-name prop) 1))			
          prop)
      (if (s-starts-with-p ":" (symbol-name prop))
          prop			
        (intern (concat ":" (symbol-name prop))))))
#+end_src
*** elg::plist-pair-p
#+begin_src emacs-lisp :results silent
(defun elg::plist-pair-p (plist key val &optional predicate)
  "Return t if PLIST has KEY and VAL pair. Tests using `equal'.
Optional PREDICATE  provides a function which performs equality test
and returns t or nil."
  (when-let ((stored-val (plist-get plist key)))
    (cond ((not predicate)
	   (equal stored-val val))
	  ((functionp predicate)
	   (funcall predicate stored-val val)))))
#+end_src
*** elg-mem-s=
#+begin_src emacs-lisp :results silent
  (defun elg--mem-s= (elt list)
    "Like memq, but comparisons done by `string='"
;; Must be an easier way to do this
    (cond ((null list) nil)
          ((string= elt (car list)) t)
          (t (elg--mem-s= elt (cdr list)))))
#+end_src
*** elg-zip
#+begin_src emacs-lisp :results silent
  (defun elg:zip (args)
    "Zips multiple lists together. Example:
    (elg:zip '((1 5 9) (2 6 10) (3 7 11) (4 8 12)))
     => '((1 2 3 4) (5 6 7 8) (9 10 11 12)).
    All lists must be the same length."
    ;; Seems like dash.el should be able to do this. 
    ;; (Maybe it does?)
    (if (catch 'match ; Check if lists are all the same length
          (dotimes (x (1- (length args)))
            (when (/= (length (nth x args))
                      (length (nth (1+ x) args)))
              (throw 'match nil)))
          (throw 'match t))
        (let (zip subzip)
          (dotimes (_ (length (car args)))
            (setq subzip nil)
            (dotimes (x (length args))
              (push (pop (nth x args)) subzip))
            (push (reverse subzip) zip))
          (reverse zip))
      (user-error "Lists are not all the same length.")))
#+end_src
** Date utilities
*** Leap year utilities
#+begin_src emacs-lisp
(defsubst elg::get-days-in-year (year)
  "Return the number of days in YEAR." 
  (if (elg::leap-year-p year) 366 365))

(defsubst elg::leap-year-p (year)
  "Return t if YEAR is a leap year. Otherwise, nil."
  (= (% year 4) 0))
#+end_src
*** Normalize date strings
#+begin_src emacs-lisp :results silent
  (defun elg::convert-date-string (date-string)
    "Converts an org date string to YYYY-MM-DD."
    ;; (when (or (string= (substring date 0 1) "<") (string= (substring date 0 1) "["))
    ;;   (setq date (substring date 1)))
    ;; (let ((new-date ""))
    ;;   (dolist (element (s-split "-"  date))
    ;;     (if (< (string-to-number element) 10)
    ;;         (setq new-date (concat new-date "0" (number-to-string (string-to-number element))))
    ;;       (setq new-date (concat new-date element))))
    ;;   (concat (substring new-date 0 4) "-" (substring new-date 4 6) "-" (substring new-date 6 8))))
  (ts-format "%Y-%m-%d" (ts-parse-org date-string)))
  ;; Does this single line create an entire dependency?
  ;; If so, does the above code works all the same?
#+end_src
*** Date calculator
#+begin_src emacs-lisp :results silent 
  (defun elg-date-calc (date offset &optional unit)
    "DATE is a string \"YYYY-MM-DD\"
    OFFSET is a positive or negative integer representing
    the number of days. UNIT should be the symbol 'day, 'month, or 'year.
    UNIT defaults to 'day.

    Returns a string \"YYYY-MM-DD\""
    (->> date
         (ts-parse)
         (ts-adjust (or unit 'day) offset)
         (ts-format "%Y-%m-%d")))
#+end_src
** Converting date to column in gantt buffer
*** date-to-column-number
#+begin_src emacs-lisp :results silent
(defun elg::convert-date-to-column-number (timestamp)
  "Accepts a date in the form of \"YYYY-MM-DD\" and returns
the column of that date."
  (let ((spaces 0)
	(date timestamp))
    (cl-subseq elg::date-range
	       0 (cl-position (string-to-number (substring date 0 4)) elg::date-range))
    ;; add the preceding years
    (dolist (year
	     (cl-subseq elg::date-range
			0 (cl-position (string-to-number (substring date 0 4)) elg::date-range)))
      (if (elg::leap-year-p year)
	  (setq spaces (+ spaces 366 12))
	(setq spaces (+ spaces 365 12))))
    ;; add the current year
    (+ spaces (elg::convert-date-to-column-in-current-year date) elg:header-column-offset)))
#+end_src 
*** date to day # in year
#+begin_src emacs-lisp :results silent
(defun elg::convert-date-string-to-day-number-in-year (date)
  "accept a date in the format YYYY-MM-DD and return an int of day number of the year"
  (time-to-day-in-year (encode-time 0 0 0 (string-to-number (substring date 8 10))
				    (string-to-number (substring date 5 7))
				    (string-to-number (substring date 0 4)))))
#+end_src 
*** date to column in year
#+begin_src emacs-lisp :results silent
(defun elg::convert-date-to-column-in-current-year (date)
  "accepts a date YYYY-MM-DD and returns the position on the horizontal calendar (int)
this works on leap years"
  (+ (elg::convert-date-string-to-day-number-in-year date)
     (- (string-to-number (substring date 5 7)) 1)))
#+end_src
** Overlay utilities
*** Create overlay
#+begin_src emacs-lisp
  (defun elg::create-overlay (&optional begin end &rest properties)
    "Create an overlay from BEGIN to END with PROPERTIES. If BEGIN is
  nil, then create the overlay at point. If END is nil, then create
  the overlay only at point. Returns the new overlay.

  Always use this when setting an overlay."
    (let ((overlay (make-overlay (or begin (point))
                                 (or end (1+ (point)))))
          (len (length properties))
          (i 0))
      (overlay-put overlay :elg t)
      (while (< i len)
        (overlay-put overlay
                     (nth i properties) (nth (setq i (1+ i)) properties))
        (setq i (1+ i)))
      (setq i 0)
      overlay))
#+end_src
* Parsing
** utilities
*** Get date range 
**** Happy to report this disaster no longer needs to exist
#+begin_src emacs-lisp :results silent
  ;; (cl-defun elg::get-years (&optional (date-type '(all)))
  ;;   "Get the date range of all time values in all agenda files. 
  ;; Optional DATE-TYPE is any value (or list of values) accepted by `org-re-timestamp':
  ;;         all: all timestamps
  ;;      active: only active timestamps (<...>)
  ;;    inactive: only inactive timestamps ([...])
  ;;   scheduled: only scheduled timestamps
  ;;    deadline: only deadline timestamps
  ;;      closed: only closed time-stamps
  ;; If it is not provided, the default is `all'."
  ;;   (save-excursion
  ;;     (let ((years '()))
  ;;       (--each (-list elg:agenda-files)
  ;;         (with-temp-buffer
  ;;           (insert-file-contents it)
  ;;           (goto-char (point-min))
  ;;           ;; HACK: Searching the complete buffer for
  ;;           ;; each type of clock seems like a 
  ;;           ;; ridiculous way to do this.
  ;;           (--each (or (-list date-type)
  ;;                       '(all))
  ;;             (goto-char (point-min))
  ;;             (while (re-search-forward (org-re-timestamp it) nil t)
  ;;               (push (substring (car (s-split "-" (match-string 0))) 1) years)))))
  ;;       (--> years
  ;;            (delete-dups it)
  ;;            (sort (mapcar #'string-to-number it) #'<)
  ;;            (when elg:start-year
  ;;              (-remove (lambda (year) (< year elg:start-year)) it))))))
#+end_src
** org parse headline function
*** Run custom parsing functions
#+begin_src emacs-lisp :results silent
  ;; (defun elg--run-parsing-functions ()
  ;;   "Run all parsing functions in `elg--parsing-functions' and
  ;; return a plist of the results."
  ;;   (-flatten-n 1
  ;;               (cl-loop for (prop . function) in elg--parsing-functions
  ;;                        collect `(,prop ,(funcall function)))))
#+end_src
*** parser
#+begin_src emacs-lisp :results silent
  (defun elg--parser ()
    (-let* (((&alist "CATEGORY" elg-category
                     "ITEM" elg-headline
                     "FILE" elg-file
                     "TIMESTAMP" elg-timestamp
                     "TIMESTAMP_IA" elg-timestamp-ia
                     "DEADLINE" elg-deadline
                     "SCHEDULED" elg-scheduled
                     "TODO" elg-todo
                     "ALLTAGS" elg-alltags
                     "ELG-DEPENDENTS" elg-dependents
                     "ELG-ANCHOR" elg-anchor)
             (org-entry-properties))
            ;; Return a new property list to be
            ;; assigned to the cell. The first set
            ;; match proerties from `org-entry-properties'.
            (props (list :elg-category elg-category
                         :elg-headline elg-headline
                         :elg-file elg-file
                         :elg-deadline (when elg-deadline
                                         (elg::convert-date-string elg-deadline))
                         :elg-scheduled (when elg-scheduled
                                          (elg::convert-date-string elg-scheduled))
                         :elg-todo elg-todo
                         :elg-marker (point-marker)
                         ;; Don't get the timestamps if they are ranges.
                         :elg-timestamp (when (and elg-timestamp
                                                   (not (s-match "--" elg-timestamp)))
                                          (elg::convert-date-string elg-timestamp))
                         :elg-timestamp-ia (when (and elg-timestamp-ia
                                                      (not (s-match "--" elg-timestamp-ia)))
                                             (elg::convert-date-string elg-timestamp-ia))
                         ;; Don't get the ranges if they are single dates.
                         :elg-timestamp-range (when elg-timestamp
                                                (if (not (s-match "--" elg-timestamp))
                                                    nil
                                                  (let ((dates (s-split "--" elg-timestamp)))
                                                    (list (elg::convert-date-string (car dates))
                                                          (elg::convert-date-string (cadr dates))))))
                         :elg-timestamp-range-ia (when elg-timestamp-ia
                                                   (if (not (s-match "--" elg-timestamp-ia))
                                                       nil
                                                     (let ((dates (s-split "--" elg-timestamp-ia)))
                                                       (list (elg::convert-date-string (car dates))
                                                             (elg::convert-date-string (cadr dates))))))
                         ;; Clean up the tags
                         :elg-alltags (when-let ((tag-string elg-alltags))
                                        (mapcar #'org-no-properties (s-split ":" tag-string t)))
                         :elg-header (pcase elg:header-type
                                       ('root (save-excursion 
                                                (while (org-up-heading-safe))
                                                (cdar (org-entry-properties (point) "ITEM"))))
                                       ('hashtag (when elg-alltags
                                                   (org-no-properties (-first (lambda (tagstring) (s-starts-with-p "#" tagstring))
                                                                              (s-split ":" tag-string)))))
                                       ('category elg-category)
                                       ((pred functionp) (funcall elg:header-type))
                                       (_ (error "Invalid header type.")))
                         :elg-org-buffer (current-buffer)
                         :elg-org-id (org-id-get-create))))
      (setq props (append props
                          ;; Set the date if it contains a date type in `elg-timestamps-to-display'
                          `(:elg-date ,(plist-get props
                                                  (elg--change-symbol (--first (plist-get props
                                                                                          (elg--change-symbol it ":elg-"))
                                                                               elg-timestamps-to-display)
                                                                      ":elg-")))
                          ;; Append properites from `org-element-at-point' in
                          ;; case anyone wants to use them
                          (cadr (org-element-at-point))
                          ;; Run all custom parsing functions and append
                          ;; those values
                          (-flatten-n 1
                                      (cl-loop for (prop . function) in elg--parsing-functions
                                               collect `(,prop ,(funcall function))))))
      ;; Return only if there is an :elg-date
      ;; FIXME: It is inefficient to calculate all of this before deciding whether to
      ;; return the value, but tests showed that it's not any more efficient to first
      ;; calculate `:elg-date' and then decide whether to proceed, likely because
      ;; `:elg-date' requires significant processing of other properties
      (when (plist-get props :elg-date)
        props)))
#+end_src
*** Parser
**** To be deleted...
#+begin_src emacs-lisp :results silent
  ;; (defun elg--old-parser ()
  ;;   (let* ((category (cdr (assoc "CATEGORY" (org-entry-properties (point) "CATEGORY"))))
  ;;          ;; For some reason, certain properties retrieved using `org-entry-properties' return
  ;;          ;; the `category' of an entry if the value is nil. For example, if there is no timestamp
  ;;          ;; in an entry, it will return the category. Thus, certain property values must be checked
  ;;          ;; against the entry's category to determine whether the value is nil. Since category
  ;;          ;; is repeatedly used, it is stored first.
  ;;          (prop-list (append
  ;;                      (list :elg-category category)
  ;;                      (list :elg-marker (point-marker))
  ;;                      (list :elg-root
  ;;                            (save-excursion 
  ;;                              (while (org-up-heading-safe))
  ;;                              (cdar (org-entry-properties (point) "ITEM"))))
  ;;                      (list :elg-todo 
  ;;                            (cdr (car (org-entry-properties (point) "TODO"))))
  ;;                      (list :elg-file 
  ;;                            (cdr (car (org-entry-properties (point) "FILE"))))
  ;;                      (list :elg-headline
  ;;                            (cdar (org-entry-properties (point) "ITEM")))
  ;;                      (list :elg-timestamp
  ;;                            (when-let ((timestamp (cdar (org-entry-properties (point) "TIMESTAMP"))))
  ;;                              (cond ((string= timestamp
  ;;                                              category)
  ;;                                     nil)
  ;;                                    ((s-match "--" timestamp)
  ;;                                     nil)
  ;;                                    (t
  ;;                                     (elg::convert-date-string timestamp)))))
  ;;                      (list :elg-timestamp-ia
  ;;                            (when-let ((timestamp-ia (cdar (org-entry-properties (point) "TIMESTAMP_IA"))))
  ;;                              (cond ((string= timestamp-ia
  ;;                                              category)
  ;;                                     nil)
  ;;                                    ((s-match "--" timestamp-ia)
  ;;                                     nil)
  ;;                                    (t
  ;;                                     (elg::convert-date-string timestamp-ia)))))
  ;;                      (list :elg-timestamp-range
  ;;                            (when-let ((range (cdar (org-entry-properties (point) "TIMESTAMP"))))
  ;;                              (cond ((string= range category)
  ;;                                     nil)
  ;;                                    ((not (s-match "--" range))
  ;;                                     nil)
  ;;                                    (t
  ;;                                     (let ((dates (s-split "--" range)))
  ;;                                       (list (elg::convert-date-string (car dates))
  ;;                                             (elg::convert-date-string (cadr dates))))))))
  ;;                      (list :elg-timestamp-ia-range
  ;;                            (when-let ((range (cdar (org-entry-properties (point) "TIMESTAMP_IA"))))
  ;;                              (cond ((string= range category)
  ;;                                     nil)
  ;;                                    ((not (s-match "--" range))
  ;;                                     nil)
  ;;                                    (t
  ;;                                     (let ((dates (s-split "--" range)))
  ;;                                       (cons (elg::convert-date-string (car dates))
  ;;                                             (elg::convert-date-string (cadr dates))))))))
  ;;                      (list :elg-deadline 
  ;;                            (when (cdr (car (org-entry-properties (point) "DEADLINE")))
  ;;                              (if (string= (cdr (car (org-entry-properties (point) "DEADLINE"))) category)
  ;;                                  nil
  ;;                                (elg::convert-date-string (cdr (car (org-entry-properties (point) "DEADLINE")))))))
  ;;                      (list :elg-hashtag
  ;;                            (when-let* ((tag-string (cdar (org-entry-properties (point) "ALLTAGS")))
  ;;                                        (hashtag (-first (lambda (tagstring) (s-starts-with-p "#" tagstring))
  ;;                                                         (s-split ":" tag-string))))
  ;;                              (org-no-properties hashtag)))
  ;;                      (list :elg-scheduled
  ;;                            (when (cdr (car (org-entry-properties (point) "SCHEDULED")))
  ;;                              (if (string= (cdr (car (org-entry-properties (point) "SCHEDULED"))) category)
  ;;                                  nil
  ;;                                (elg::convert-date-string (cdr (car (org-entry-properties (point) "SCHEDULED")))))))
  ;;                      (list :elg-alltags
  ;;                            (when-let ((tag-string (cdar (org-entry-properties (point) "ALLTAGS"))))
  ;;                              (mapcar #'org-no-properties (s-split ":" tag-string t))))
  ;;                      (list :elg-header
  ;;                            (pcase elg:header-type
  ;;                              ('root 
  ;;                               (save-excursion 
  ;;                                 (while (org-up-heading-safe))
  ;;                                 (cdar (org-entry-properties (point) "ITEM"))))
  ;;                              ('hashtag 
  ;;                               (when-let ((tag-string (cdar (org-entry-properties (point) "ALLTAGS"))))
  ;;                                 (substring 
  ;;                                  (-first (lambda (tagstring) (s-starts-with-p "#" tagstring))
  ;;                                          (s-split ":" tag-string))
  ;;                                  1)))
  ;;                              ('category  category)
  ;;                              ((pred functionp) (funcall elg:header-type))
  ;;                              (_ (error "Invalid header type."))))
  ;;                      (list :elg-org-buffer
  ;;                            (current-buffer))
  ;;                      (list :elg-dependents
  ;;                            (cdar (org-entry-properties (point) "ELGANTT-DEPENDENTS")))
  ;;                      (list :elg-anchor
  ;;                            (org-entry-get (point) "ELGANTT-ANCHOR"))
  ;;                      (list :elg-org-id
  ;;                            (org-id-get-create))
  ;;                      (list :fuck-you t))))
  ;;     (setq prop-list (append 
  ;;                      (cond ((plist-get prop-list :elg-deadline)
  ;;                             (list :elg-date (plist-get prop-list :elg-deadline)
  ;;                                   :elg-type 'deadline))
  ;;                            ;; :elg-display-char (org-no-properties (elg::get-display-char 'deadline))))
  ;;                            ;;'display (org-no-properties (elg::get-display-char 'deadline))))
  ;;                            ((plist-get prop-list :elg-timestamp)
  ;;                             (list :elg-date (plist-get prop-list :elg-timestamp)
  ;;                                   :elg-type 'timestamp))
  ;;                            ;; :elg-display-char (org-no-properties (elg::get-display-char 'timestamp))))
  ;;                            ;;'display (org-no-properties (elg::get-display-char 'timestamp))))
  ;;                            ((plist-get prop-list :elg-scheduled)
  ;;                             (list :elg-date (plist-get prop-list :elg-scheduled)
  ;;                                   :elg-type 'scheduled))
  ;;                            ;; :elg-display-char (org-no-properties (elg::get-display-char 'scheduled))))
  ;;                            ((plist-get prop-list :elg-timestamp-range)
  ;;                             (list :elg-date (plist-get prop-list :elg-timestamp-range)
  ;;                                   :elg-type 'range))
  ;;                            ;;'display (org-no-properties (elg::get-display-char 'timestamp-ia))))
  ;;                            ((plist-get prop-list :elg-timestamp-ia)
  ;;                             (list :elg-date (plist-get prop-list :elg-timestamp-ia)
  ;;                                   :elg-type 'timestamp-ia)))
  ;;                      ;; :elg-display-char (org-no-properties (elg::get-display-char 'timestamp-ia)))))
  ;;                      ;;'display (org-no-properties (elg::get-display-char 'scheduled)))))
  ;;                      (list :elg-anchor-date
  ;;                            (when-let ((anchor-id (plist-get prop-list :elg-anchor))
  ;;                                       (id-point (cdr (org-id-find anchor-id))))
  ;;                              (save-excursion 
  ;;                                (goto-char id-point)
  ;;                                (plist-get (elg--parser) :elg-date))))
  ;;                      (cadr (org-element-at-point))
  ;;                      (elg--run-parsing-functions)
  ;;                      prop-list))
  ;;     ;; only return those that have a date property 
  ;;     (when (plist-get prop-list :elg-date)
  ;;       prop-list)))
#+end_src
** org iterator function
*** task Decide how to handle archives
#+begin_src emacs-lisp :results silent
  (defun elg--iterate ()
    "Iterate over all entries."
    ;; org-ql is much faster than org-map-entries.
    (if (fboundp 'org-ql-select)
        (mapc #'elg::insert-entry
              (-non-nil
               (org-ql-select elg:agenda-files
                 `(ts :from ,(concat (number-to-string elg:start-year) "-01-01"))
                 :action #'elg--parser)))
      (mapc #'elg::insert-entry
            (-non-nil
             (org-map-entries #'elg--parser
                              nil
                              (-list elg:agenda-files)
                              'archive)))))
#+end_src
* Calendar buffer
** Utilities
*** on a vertical line?
#+begin_src emacs-lisp :results silent
  (defun elg::on-vertical-line ()
    (string= "|" (buffer-substring (point) (1+ (point)))))
  (defun elg::on-vertical-line* ()
    (looking-at "|"))
#+end_src
** Getting data from the calendar buffer
*** get character to display
**** TODO I believe this function is obsolete 
#+begin_src emacs-lisp :results silent
  ;; (defun elg::get-display-char (type)
  ;;   "Get the character to insert."
  ;;   (pcase type
  ;;     ('deadline elg-cal-deadline-character)
  ;;     ('timestamp elg-cal-active-timestamp-character)
  ;;     ('timestamp-ia elg-cal-inactive-timestamp-character)
  ;;     ('multiple elg-cal-multiple-entry-character)
  ;;     ('scheduled elg-cal-scheduled-character)))
#+end_src
*** select from multiple entry
#+begin_src emacs-lisp :results silent
  (defun elg::select-entry (&optional prop-or-all val)
    "Prompt the user to select from multiple entries.
  If PROP is `all', then skip the prompt and return the
  list of all props at point. (i.e., the same thing as
  `elg:get-props-at-point')"
    (when-let ((prop-list (elg:get-prop-at-point)))
      (cond ((eq prop-or-all 'all)
             ;; If user wants all entries, return them
             prop-list)
            ((= (length prop-list) 1)
             ;; If there is only one entry, return it,
             ;; as an unnested list (hence the use of car).
             ;; If there are two entries with 'all, it
             ;;  will return a nested list; if there 
             ;; is one entry, the list is not nested. 

             ;; TODO figure out why I wrote it this way
             (car prop-list))
            (t
             ;; Otherwise, there are more than one entry
             ;; and the user only wants one of them.
             ;; Prompt the user to select which one. 

             ;; TODO turn this into an elg-selection-function that
             ;; can be customized by the user
             (let ((selection (completing-read "Select entry: "
                                               (elg:get-prop-at-point :elg-headline)
                                               nil
                                               'require-match)))
               (-first (lambda (x) (-contains? x selection)) prop-list))))))
#+end_src
*** get header at point
#+begin_src emacs-lisp :results silent
  (defun elg:get-header-at-point ()
    "Get's the header of the cell's current position.
  Returns nil if not on a header line."
    (save-excursion
      (beginning-of-line)
      (get-text-property (point) 'elg-header)))
#+end_src
*** get date at point
#+begin_src emacs-lisp :results silent
  ;; (defun elg:get-date-at-point (&optional column)
  ;;   "Get the date at point in YYYY-MM-DD format."
  ;;   ;; This code is a disaster!
  ;;   (let ((deactivate-mark t)) 
  ;;     (if (not (char-equal (char-after) ?|))
  ;;         (progn
  ;;           (when (not column)
  ;;             (setq column (current-column)))
  ;;           (let ((current-point (point))
  ;;                 (date ""))
  ;;             (save-excursion
  ;;               (if (re-search-backward "|" nil t)
  ;;                   (progn 
  ;;                     (setq date (number-to-string (- current-point (match-beginning 0))))
  ;;                     (goto-char (point-min))
  ;;                     (move-to-column column)
  ;;                     (if (re-search-backward "|" nil t)
  ;;                         (progn
  ;;                           (re-search-forward "[[:alpha:]]+" nil t)
  ;;                           (setq date (concat (match-string 0) " " date))
  ;;                           (if (re-search-forward "[[:digit:]]+" nil t)
  ;;                               (progn
  ;;                                 (setq date (concat date ", " (match-string 0)))
  ;;                                 (let ((day (org-day-of-week (nth 3 (parse-time-string date))
  ;;                                                             (nth 4 (parse-time-string date))
  ;;                                                             (nth 5 (parse-time-string date))))
  ;;                                       (text ""))
  ;;                                   (cond ((= day 0) (setq text "Monday, "))
  ;;                                         ((= day 1) (setq text "Tuesday, "))
  ;;                                         ((= day 2) (setq text "Wednesday, "))
  ;;                                         ((= day 3) (setq text "Thursday, "))
  ;;                                         ((= day 4) (setq text "Friday, "))
  ;;                                         ((= day 5) (setq text "Saturday, "))
  ;;                                         ((= day 6) (setq text "Sunday, ")))
  ;;                                   (setq date (concat text date))))
  ;;                             (setq date "")))
  ;;                       (setq date "")))
  ;;                 (setq date "")))
  ;;             date))
  ;;       "")))

  (defun elg:get-date-at-point (&optional column)
    "Get the date at point in YYYY-MM-DD format."
    ;; FIXME: the need should be obvious.
    (let ((deactivate-mark t)) 
      (if (not (char-equal (char-after) ?|))
          (progn
            (when (not column)
              (setq column (current-column)))
            (let ((current-point (point))
                  (date ""))
              (save-excursion
                (if (re-search-backward "|" nil t)
                    (progn 
                      (setq date (number-to-string (- current-point (match-beginning 0))))
                      (goto-char (point-min))
                      (move-to-column column)
                      (if (re-search-backward "|" nil t)
                          (progn
                            (re-search-forward "[[:alpha:]]+" nil t)
                            (setq date (concat (match-string 0) " " date))
                            (if (re-search-forward "[[:digit:]]+" nil t)
                                (progn
                                  (setq date (concat date " " (match-string 0)))
                                  (let ((day (org-day-of-week (nth 3 (parse-time-string date))
                                                              (nth 4 (parse-time-string date))
                                                              (nth 5 (parse-time-string date)))))
                                    (setq date (concat date)))
                                  (setq date (ts-format "%Y-%m-%d" (ts-parse date))))
                              (setq date "")))
                        (setq date "")))
                  (setq date "")))
              date))
        "")))
#+end_src
*** get property or properties at point
#+begin_src emacs-lisp :results silent
  (defun elg:get-prop-at-point (&optional prop)
    "Returns all text properties at point. If a property is 
  specified, then return that property for each entry at point if 
  there are multiple entries.

  If there is only one entry, the value will be returned as a list of 
  one item."
    (let ((prop-list (plist-get (text-properties-at (point)) :elg)))
      (if prop
          (mapcar (lambda (props) (plist-get props prop))
                  prop-list)
        prop-list)))
#+end_src
* User movement functions
** Scrolling
#+begin_src emacs-lisp :results silent
  (defun elg--next-line ()
    (interactive)
    (search-forward "|" (point-at-eol) t))

  (defun elg-scroll (direction)
    ;; HACK - This his horrible code, but it works.
    "Place, or move, an overlay on each line, hiding (or showing)
    the month immediately after the headers.
    DIRECTION must be a symbol: `forward' or `backard'."
    (let ((column (current-column))
          (line (line-number-at-pos)))
      (cond ((and (not elg--hidden-overlays)
                  (eq direction 'forward))
             (progn
               (goto-char (point-min))
               (setq elg--hidden-overlays 
                     (cl-loop with num-lines = (count-lines (point-min) (point-max))
                              for line from 1 to num-lines
                              collect (make-overlay (progn (move-to-column (1+ elg:header-column-offset)) (point))
                                                    (elg--next-line))
                              until (= (line-number-at-pos) num-lines)
                              do (next-line)))
               (cl-loop for overlay in elg--hidden-overlays
                        do (overlay-put overlay 'invisible t))))
            (elg--hidden-overlays
             (let ((end (pcase direction
                          (`forward
                           (lambda (overlay)
                             (save-excursion
                               (goto-char (overlay-end overlay))
                               (search-forward "|" (point-at-eol) t))))
                          (`backward
                           (lambda (overlay)
                             (goto-char (overlay-end overlay))
                             (search-backward "|" (point-at-bol) t)
                             (let ((x (search-backward "|" (point-at-bol) t)))
                               (when x
                                 (1+ x))))))))
               (if (funcall end (car elg--hidden-overlays))
                   (cl-loop for overlay in elg--hidden-overlays
                            do (move-overlay overlay
                                             (overlay-start overlay)
                                             (funcall end overlay)))
                 (when (eq direction 'backward)
                   (setq elg--hidden-overlays nil))))))
      ;; This is an elaborate `save-excursion' to try to keep the
      ;; point in a reasonable place
      (goto-line line)
      (move-to-column column)))


  (defun elg-scroll-forward ()
    "Interactive function to scroll forward by one month."
    (interactive)
    (elg-scroll 'forward))

  (defun elg-scroll-backward ()
    "Interactive function to scroll forward by one month."
    (interactive)
    (elg-scroll 'backward))
#+end_src
** Jump forward/backward
#+begin_src emacs-lisp :results silent
  (defun elg::move-selection-bar-forward ()
    "Not a selection bar. For now, just the cursor.
  Moves to the next filled cell on the line. Does not move to 
  next line if it is at the last entry on the line."
    (interactive)
    (when (<= (line-number-at-pos) 2)
      (goto-line 3))
    (when (<= (current-column) elg:header-column-offset)
      (forward-char elg:header-column-offset))
    (when-let ((point (save-excursion 
                        (forward-char 1)
                        (re-search-forward elg:cell-entry-re
                                           (point-at-eol)
                                           t))))
      (goto-char (1- point))))

  (defun elg::move-selection-bar-backward ()
    "Not a selection bar. For now, just the cursor."
    (interactive)
    (when-let ((point (re-search-backward elg:cell-entry-re
                                          (point-at-bol)
                                          t)))
      (goto-char point)))

  (defun elg--goto-next ()
    (elg::move-selection-bar-forward))
  (defun elg--goto-previous
    (elg::move-selection-bar-backward))
#+end_src
** Vertical movement
#+begin_src emacs-lisp :results silent
(defsubst elg::move-up ()
  (interactive)
  (elg::move-vertically 'up))

(defsubst elg::move-down ()
  (interactive)
  (elg::move-vertically 'down))

(cl-defun elg::move-vertically (up-or-down)
  (if (eq up-or-down 'up)
      (if (> (org-current-line) 3)
	  (previous-line)
	(return-from elg::move-vertically nil))
    (if (< (org-current-line) (count-lines (point-min) (point-max)))
	(next-line)
      (return-from elg::move-vertically nil)))
  (let ((next (save-excursion (re-search-forward elg:cell-entry-re (point-at-eol) t)))
	(previous (save-excursion (re-search-backward elg:cell-entry-re (point-at-bol) t))))
    (cond ((and (not next) (not previous))
	   (elg::move-vertically up-or-down))
	  ((and (not next) previous)
	   (goto-char previous))
	  ((and (not previous) next)
	   (goto-char (1- next)))
	  (t (if (< (- next (point)) (- (point) previous))
		 (goto-char (1- next))
	       (goto-char previous))))))
#+end_src
** Horizontal movement
#+begin_src emacs-lisp :results silent 
(defun elg::move-horizontally (n)
  "Ensures that the point is not on a vertical line."
  (forward-char n)
  (when (elg::on-vertical-line)
    (if (< n 0)
	(backward-char)
      (forward-char))))
#+end_src
* Programmatic movement functions 
** Goto ID
#+begin_src emacs-lisp :results silent
(defun elg::goto-id (id)
  "Go to the cell for the org entry with ID. Return nil if not found."
  ;; Note: we cannot use `text-property-any' to find the value because
  ;; comparisons are done using `eq' which will not work for string values.
  (when-let ((point (cl-loop for points being the intervals of (current-buffer) property :elg
			     thereis (save-excursion
				       (goto-char (car points))
				       (let ((props (elg:get-prop-at-point)))
					 (when (-first (lambda (x)
							 (-contains? x id))
						       props)
					   (car points)))))))
    (goto-char point)))
#+end_src
** Goto date
#+begin_src emacs-lisp :results silent
  (defun elg--goto-date (date)
    "Go to DATE in the current header. DATE is a string in \"YYYY-MM-DD\" format."
    (beginning-of-line)
    (forward-char 
     (elg::convert-date-to-column-number date)))
#+end_src
* Interaction functions
** Shift date at point
#+begin_src emacs-lisp :results silent
  (defun elg::shift-date (n &optional properties)
    "Move the timestamp up or down by one day.
  N should be 1 or -1. The return value
  is the prop list of the entry that has been moved."
    ;; Moving by single day is the easiest way to handle this,
    ;; rather than moving by week or month, etc. 
    (unless (or (= n 1)
                (= n -1))
      (error "elg::shift-date: Invalid argument. N must be 1 or -1."))
    (let ((props (or properties
                     (elg::select-entry))))
      (elg:with-point-at-orig-entry props
          (when (re-search-forward (org-re-timestamp 'all))
            (org-timestamp-change n 'day)))
      (elg:update-this-cell)
      (pcase n
        (1  (elg::move-horizontally 1)
            (elg:update-this-cell))
        (-1 (elg::move-horizontally -1)
            (elg:update-this-cell)))
      props))

  (defun elg::shift-date-forward ()
    (interactive)
    (elg::shift-date 1))

  (defun elg::shift-date-backward ()
    (interactive)
    (elg::shift-date -1))
#+end_src
** Open agenda for date at point
#+begin_src emacs-lisp :results silent
(defun elg::open-org-agenda-at-date ()
  (interactive)
  (let ((date (ts-format "%Y-%m-%d" (ts-parse (elg:get-date-at-point)))))
    (org-agenda-list nil date 'day))
  (other-window 1))
#+end_src
** Navigate to org file
#+begin_src emacs-lisp :results silent
(defun elg:navigate-to-org-file ()
  "Navigate to a location in an org file when
supplied with the file name (string) and point (number)."
  (interactive)
  (if-let* ((props (elg::select-entry))
	    (buffer (plist-get props :elg-org-buffer))
	    (marker (plist-get props :elg-marker)))
      (progn 
	(switch-to-buffer-other-window buffer)
        (org-goto-marker-or-bmk marker)
	(outline-show-children)
	(outline-show-entry)
	(beginning-of-line))
    (message "Cannot navigate to org file: no data at point.")))
#+end_src
** Macro: with point at orig entry
#+begin_src emacs-lisp :results silent
  (defmacro elg:with-point-at-orig-entry (props &rest body)
    "Execute BODY with point at marker stored in `:elg-marker'.
  Buffer is retrieved from the `:elg-org-buffer' property. If PROPS is nil, 
  then retrieve PROPS with `elg::select-entry’.
  If PROPS is supplied, use those props instead of the props at point.
This, annoyingly, will often require it to be called with a `nil' argument"
    (declare (indent 2))
    `(let* ((props (or ,props ',(elg::select-entry)))
            (marker (plist-get props :elg-marker))
            (buffer (plist-get props :elg-org-buffer)))
         (with-current-buffer buffer
           (when (or (> marker (point-max))
                     (< marker (point-min)))
             (widen))
           (goto-char marker)
           ,@body)))
#+end_src
* Insertion functions
** Draw top-level month and date lines
#+begin_src emacs-lisp :results silent 

  ;; (defun elg::draw-month-line ()
  ;;   ;; (let ((calendar-line ""))
  ;;   ;;   (dolist (year elg::date-range)
  ;;   ;;     (if (elg::leap-year-p year)
  ;;   ;;         (setq calendar-line (concat calendar-line 
  ;;   ;;                                     (replace-regexp-in-string "xxxx" (number-to-string year) 
  ;;   ;;                                                               elg:leap-year-month-line)))
  ;;   ;;       (setq calendar-line (concat calendar-line
  ;;   ;;                                   (replace-regexp-in-string "xxxx" (number-to-string year) 
  ;;   ;;                                                             elg:normal-year-month-line)))))
  ;;   (insert (make-string elg:header-column-offset ? )))

  ;; (defun elg::draw-number-line ()
  ;;   ;; (let ((number-line ""))
  ;;   ;;   (dolist (year elg::date-range)
  ;;   ;;     (if (elg::leap-year-p year)
  ;;   ;;         (setq number-line (concat number-line elg:leap-year-date-line))
  ;;   ;;       (setq number-line (concat number-line elg:normal-year-date-line))))
  ;;   (insert 
  ;;    (make-string elg:header-column-offset ? )))

  (defun elg::draw-month-line* (year)
    (insert 
     (if (elg::leap-year-p year)
         (replace-regexp-in-string "xxxx" (number-to-string year) 
                                   elg:leap-year-month-line)
       (replace-regexp-in-string "xxxx" (number-to-string year) 
                                 elg:normal-year-month-line))))

  (defun elg::draw-number-line* (year)
    (insert (if (elg::leap-year-p year)
                elg:leap-year-date-line
              elg:normal-year-date-line)))

  (defun elg::draw-blank-line* (year)
    (insert (if (elg::leap-year-p year)
                elg:leap-year-blank-line
              elg:normal-year-blank-line)))
#+end_src
** Get/create calendar header lines
#+begin_src emacs-lisp :results silent 
  (defun elg::get-header-create (header)
    "Put point at the first char in the HEADER line, creating a new header
  line if one does not exist."
    (goto-char (point-min))
    (let ((new-header (concat (s-truncate elg:header-column-offset header))))
      ;; Concat is necessary for reasons I do not understand. Without it,
      ;; the text properties are not set propertly. 
      (if (search-forward new-header nil t)
          (beginning-of-line)
        (put-text-property 0 (length new-header) 'elg-header header new-header)
        (elg::insert-new-header-line new-header)
        (beginning-of-line))))

  (defun elg::insert-new-header-line (header)
    "Inserts a new header."
    (goto-char (point-max))
    (insert "\n"
            (substring 
             (concat header (make-string elg:header-column-offset ? ))
             0 elg:header-column-offset))
    (cl-loop for year in elg::date-range
             do (if (elg::leap-year-p year)
                    (insert elg:leap-year-blank-line)
                  (insert elg:normal-year-blank-line))))
#+end_src 
** Creating and and inserting years
#+begin_src emacs-lisp :results silent
  (defun elg--insert-year (year &optional append)
    "For each line in the calendar, insert the appropriate
  lines to display YEAR. If APPEND is t, then add the years
  to the end of the calendar. (This should be calculated automatically, 
  but currently it is not.)"
    (goto-char (point-min))
    (if append
        (end-of-line)
      (move-to-column elg:header-column-offset))
    (elg::draw-month-line* year)
    (next-line)
    (if append
        (end-of-line)
      (move-to-column elg:header-column-offset))
    (elg::draw-number-line* year)
    (cl-loop until (progn (end-of-line)
                          (eobp))
             do (progn (next-line)
                       (if append
                           (end-of-line)
                         (move-to-column elg:header-column-offset))
                       (elg::draw-blank-line* year))))

  (defun elg--add-year (year)
    "Check to see if YEAR has already been displayed in the calendar.
  If so, do nothing. If not, insert that year for all calendar lines
  and all header lines in the calendar, and push the year onto 
  `elg::date-range' so that any new entries will contain the 
  proper number of years."
    (when (not (memq year elg::date-range))
      (cond ((not elg::date-range)
             (cl-pushnew year elg::date-range)
             (elg--insert-year year))
            ((< year (first elg::date-range))
             (let ((dif (- (first elg::date-range) year)))
               (setq year (first elg::date-range))
               (dotimes (_ dif)
                 (setq year (1- year))
                 (cl-pushnew year elg::date-range)
                 (elg--insert-year year))))
            ((> year (car (last elg::date-range)))
             (let ((dif (- year (car (last elg::date-range)))))
               (setq year (car (last elg::date-range)))
               (dotimes (_ dif)
                 (setq year (1+ year))
                 (cl-pushnew year elg::date-range)
                 (elg--insert-year year t)))))
      (setq elg::date-range (sort elg::date-range #'<))))
#+end_src
** Insert text properties into calendar 
#+begin_src emacs-lisp :results silent
  ;; (defun elg::insert-entry (props)
  ;;   "Inserts text properties of a cell at point, keeping any properties which
  ;; are already present. Updates the cell's display."
  ;;   (mapc (lambda (date) 
  ;;           (elg::get-header-create (plist-get props :elg-header))
  ;;           (elg--add-year (string-to-number (substring date 0 4)))
  ;;           (move-to-column (elg::convert-date-to-column-number date))
  ;;           (let ((old-props (plist-get (text-properties-at (point)) :elg)))
  ;;             (if old-props
  ;;                 (set-text-properties (point) (1+ (point)) `(:elg ,(append old-props
  ;;                                                                           (list props))))
  ;;               (set-text-properties (point) (1+ (point)) `(:elg ,(list props)))))
  ;;           (elg--update-cell-display))
  ;;         (-list (plist-get props :elg-date))))

  (defun elg::insert-entry (props)
    "Inserts text properties of a cell at point, keeping any properties which
    are already present. Updates the cell's display."
    (let ((date (plist-get props :elg-date)))
      (elg::get-header-create (plist-get props :elg-header))
      (elg--add-year (string-to-number (substring date 0 4)))
      (move-to-column (elg::convert-date-to-column-number date))
      (let ((old-props (plist-get (text-properties-at (point)) :elg)))
        (if old-props
            (set-text-properties (point) (1+ (point)) `(:elg ,(append old-props
                                                                      (list props))))
          (set-text-properties (point) (1+ (point)) `(:elg ,(list props)))))
      (elg--update-cell-display)))

#+end_src
** Change char at point
#+begin_src emacs-lisp :results silent
  (defun elg::change-char (char &optional point)
    "Replace the character at point with CHAR, preserving all 
  existing text properties."
    (save-excursion 
      (let ((props (elg:get-prop-at-point)))
        (when point (goto-char point))
        (delete-char 1)
        (insert char)
        (backward-char)
        (set-text-properties (point) (1+ (point)) `(:elg ,props)))))
#+end_src 
* Major mode
** Keymap
#+begin_src emacs-lisp :results silent
  (setq elg-mode-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "x")   #'elg-interact-mode)
          (define-key map (kbd "r")   #'elg:open)
          (define-key map (kbd "SPC") #'elg:navigate-to-org-file)
          (define-key map (kbd "p")   #'elg::move-up)
          (define-key map (kbd "a")   #'elgantt-interaction::start-action)
          (define-key map (kbd "n")   #'elg::move-down)
          (define-key map (kbd "f")   #'elg::move-selection-bar-forward)
          (define-key map (kbd "F")   #'elg-scroll-forward)
          (define-key map (kbd "B")   #'elg-scroll-backward)
          (define-key map (kbd "b")   #'elg::move-selection-bar-backward)
          (define-key map (kbd "RET") #'elg::org-agenda-at-date)
          (define-key map (kbd "M-f") #'elg::shift-date-forward)
          (define-key map (kbd "M-b") #'elg::shift-date-backward)
          (define-key map (kbd "C-M-f") #'elg:move-date-and-dependents-forward)
          (define-key map (kbd "C-M-b") #'elg:move-date-and-dependents-backward)
          map))
#+end_src
** Major mode
#+begin_src emacs-lisp :results silent 
  (define-derived-mode elg-mode special-mode
    "El Gantt"
    "Horizontal calendar interface for orgmode. \{keymap}"
    (setq header-line-format elg-header-line-format)
    (read-only-mode -1)
    (toggle-truncate-lines 1)
    (setq header-line-format elg-header-line-format)
    (add-hook 'post-command-hook #'elg--vertical-highlight nil t))
#+end_src
* Display
** Drawing displays
#+begin_src emacs-lisp :results silent 
  (defun elg--draw-display ()
    (ov-clear)
    (save-excursion
      (goto-char (point-min))
      (while (next-single-property-change (point) :elg)
        (goto-char (next-single-property-change (point) :elg))
        (when (get-text-property (point) :elg)
          (elg--display-rule-display-char)
          (cl-loop for func in elg--display-rules
                   do (funcall func))))))
#+end_src
** Update cell display
#+begin_src emacs-lisp
  (defun elg--update-cell-display ()
    (elg--display-rule-display-char)
    (cl-loop for func in elg--display-rules
             do (funcall func)))
#+end_src

#+RESULTS:
: elg--update-cell-display

** Drawing overlays
*** Overlay drawing utilities
**** Set face at point
#+begin_src emacs-lisp :results silent
  (defun elg::set-face (face &optional begin end &rest props)
    "Puts an overlay with FACE at point, and set the overlay property `elg-ov'
    to t. FACE can be any value accepted by the 'face overlay property. BEGIN
    is the start point. END is the end. If END or both are omitted, 
    then the face is set at point. PRIORITY corresponds to the 
    overlay priority property."
    (ov (or begin (point)) (or end (1+ (point))) 'face face
        'elg-ov t
        'priority priority))
#+end_src
**** Color conversion utilities
#+begin_src emacs-lisp :results silent
  (defun elg--color-rgb-to-hex (color)
    "Convert an RBG tuple '(R G B) to six digit hex string \"#RRGGBB\""
    (pcase-let ((`(,r ,g ,b) color))
      (color-rgb-to-hex r g b 2)))

  (defun elg--color-name-to-hex (color)
    "Convert named color to six digit hex color."
    (eval `(color-rgb-to-hex ,@(color-name-to-rgb color) 2)))

  (defalias 'elg--color-name-to-rgb #'color-name-to-rgb)

  (defun elg--color-hex-to-rgb (hex-color)
    "Convert hex color to RGB tuple."
    `(,(string-to-number (substring hex-color 1 3) 16)
      ,(string-to-number (substring hex-color 3 5) 16)
      ,(string-to-number (substring hex-color 5 7) 16)))

  (defun elg--color-to-rgb (color)
    "Convert a color name or hex color to RGB tuple."
    (pcase color
      ;; If it's hex...
      ((and (pred stringp)
            (pred (s-starts-with-p "#")))
       (elg--color-hex-to-rgb color))
      ;; If it's a string (trust the user that the color
      ;; name is in `list-colors-display')...
      ((pred stringp)
       (elg--color-name-to-rgb color))
      ;; If it's already an RGB tuple...
      ((and `(,r ,g ,b)
            (guard (numberp r))
            (guard (numberp g))
            (guard (numberp b)))
       color)
      ;; Otherwise...
      (_ (error "Color type must be hex, e.g., \"#ffccaa\" or color name, e.g., \"red\" or an RGB tuple, e.g., '(1.0 .5 0)"))))
#+end_src
**** Gradients
#+begin_src emacs-lisp :results silent
  (defun elg--get-color-midpoint (color1 color2)
    "Take two colors (any format) and return their
  average as an RGB tuple."
    (let ((color1 (elg--color-to-rgb color1))
          (color2 (elg--color-to-rgb color2)))
      (-zip-with (lambda (c1 c2)
                   (/ (+ c1 c2) 2))
                 color1 color2)))

  (defun elg--draw-two-color-block (start-color end-color start end divider)
    (let ((start-color (elg--color-name-to-hex start-color))
          (end-color (elg--color-name-to-hex end-color)))
      (save-excursion
        (goto-char start)
        (cl-loop for x from start to end
                 do (goto-char x)
                 (ov-clear (point) (1+ (point)))
                 (ov (point)
                     (1+ (point))
                     'face
                     (if (<= (point) divider)
                         `(:background ,start-color)
                       `(:background ,end-color)))
                 (forward-char)))))

  (defun elg--draw-gradient (start-color end-color start end &optional mid-point)
    (let ((color-gradient
           (let ((start-color (elg--color-to-rgb start-color))
                 (end-color (elg--color-to-rgb end-color)))
             (if mid-point
                 (let ((mid-color (elg--get-color-midpoint start-color
                                                           end-color)))
                   (append (color-gradient
                            start-color
                            mid-color
                            (1+ (- mid-point start))
                            (color-gradient mid-color
                                            end-color
                                            (- steps mid-point)))))
               (color-gradient start-color
                               end-color
                               (1+ (- end start)))))))
      (save-excursion
        (goto-char start)
        (mapc (lambda (color)
                (ov (point)
                    (1+ (point))
                    'face
                    `(:background ,(elg--color-rgb-to-hex color)))
                (forward-char))
              color-gradient))))

#+end_src
**** Change brightness at point
#+begin_src emacs-lisp :results silent
   (defun elg--change-brightness-of-background-at-point (point change)
    "if there is a background font lock color, this will change its brightness"
    (let ((overlay (make-overlay point (1+ point))))
      (overlay-put overlay 'priority 999)
      (overlay-put overlay 'face `(:background ,(color-lighten-name
                                                 (background-color-at-point) change)))))
#+end_src
*** Vertical selection bar
#+begin_src emacs-lisp :results silent 
  (setq elg--vertical-bar-overlay-list nil)
  (defun elg--vertical-highlight ()
    (ov-clear 'elg-vertical-highlight)
    (cl-loop with overlay = nil
             with line-length = (- (point-at-eol) (point-at-bol))
             with point = (cl-loop with point = (point)
                                   until (< point line-length)
                                   do (setq point (- point line-length 1))
                                   finally return point)
             until (> point (point-max))
             do (progn (push (make-overlay point (1+ point)) elg--vertical-bar-overlay-list)
                       (overlay-put (car elg--vertical-bar-overlay-list) 'priority 9999)
                       (overlay-put (car elg--vertical-bar-overlay-list) 'elg-vertical-highlight t)
                       (overlay-put (car elg--vertical-bar-overlay-list) 'face `(:background ,(color-lighten-name
                                                                                               (save-excursion
                                                                                                 (goto-char point)
                                                                                                 (background-color-at-point)) 15)))
                       (setq point (+ point line-length 1)))))
#+end_src
*** Highlight current day
#+begin_src emacs-lisp :results silent 
  (defun elg--highlight-current-day ()
    (interactive)
    (save-excursion 
      (goto-char (point-min))
      (let ((date-line (elg::convert-date-to-column-number (format-time-string "%Y-%m-%d")))
            (x 1)
            (total-lines (count-lines (point-min) (point-max))))
        (while (<= x total-lines)
          (move-beginning-of-line 1)
          (forward-char date-line)
          ;;(elg::set-face '(:box t) (point))
          (elg--change-brightness-of-background-at-point (point) +30)
          (forward-line)
          (setq x (1+ x))))
      (goto-char (point-min))))
#+end_src
* Refreshing
** Run org-ql for cell at point
*** TODO delete this if it is not being used 
#+begin_src emacs-lisp :results silent
  ;; (defun elg::run-org-ql-for-date-at-point ()
  ;;   (interactive)
  ;;   (when-let* ((date (elg:get-date-at-point))
  ;;               (type (pcase elg:header-type
  ;;                       ('root 'ancestors)
  ;;                       ('category 'category)
  ;;                       ('hashtag 'tags-inherited)))
  ;;               ;; ((pred functionp) (funcall type))))
  ;;               (header (elg:get-header-at-point))
  ;;               (item (pcase type
  ;;                       ('category header)
  ;;                       ('hashtag header)
  ;;                       ('ancestors `(regexp ,header)))))
  ;;     (org-ql-select elg:agenda-files
  ;;       `(and (ts :on ,date)
  ;;             (,type ,item))
  ;;       :action #'elg--parser)))
#+end_src
** Refresh this cell
#+begin_src emacs-lisp :results silent 
  (defun elg:update-this-cell (&optional no-redraw date header type item)
    "Gets data for a specific cell by looking for any headings
    which occur on the operative date."
    (when (elg::on-vertical-line)
      (user-error "Error in elg:update-this-cell: Not on a calendar cell."))
    ;; I don't know why I am saving this excursion.
    (save-excursion 
      (delete-char 1)
      (insert " ")
      (backward-char)
      (when-let* ((date (or date 
                            (elg:get-date-at-point)))
                  ;; (header (or header
                  ;;             (elg:get-header-at-point)))
                  ;; (type (or type
                  ;;           (pcase elg:header-type
                  ;;             ('root 'ancestors)
                  ;;             ('category 'category)
                  ;;             ('hashtag 'tags-inherited))))
                  ;; (item (or item
                  ;;           (pcase type
                  ;;             ('category header)
                  ;;             ('hashtag header)
                  ;;             ('ancestors `(regexp ,header))))))
                  )
        (mapc #'elg::insert-entry
              (-non-nil
               ;; -non-nil is necessary because elg--parser
               ;; returns nil if the entry does not match.
               ;; Probably should fix this. 
               (org-ql-select elg:agenda-files
                 `(ts :on ,date)
                 :action #'elg--parser))))))
#+end_src

#+RESULTS:
: elg:update-this-cell

*** OLD VERSION
#+begin_src emacs-lisp :results silent
  ;; (defun elg:update-this-cell (&optional no-redraw date header type item)
  ;;   "Gets data for a specific cell by looking for any headings
  ;;   which occur on the operative date."
  ;;   (when (elg::on-vertical-line)
  ;;     (user-error "Error in elg:update-this-cell: Not on a calendar cell."))
  ;;   ;; I don't know why I am saving this excursion.
  ;;   (save-excursion 
  ;;     (delete-char 1)
  ;;     (insert " ")
  ;;     (backward-char)
  ;;     (when-let* ((date (or date 
  ;;                           (elg:get-date-at-point)))
  ;;                 (header (or header
  ;;                             (elg:get-header-at-point)))
  ;;                 (type (or type
  ;;                           (pcase elg:header-type
  ;;                             ('root 'ancestors)
  ;;                             ('category 'category)
  ;;                             ('hashtag 'tags-inherited))))
  ;;                 (item (or item
  ;;                           (pcase type
  ;;                             ('category header)
  ;;                             ('hashtag header)
  ;;                             ('ancestors `(regexp ,header))))))
  ;;       (mapc #'elg::insert-entry
  ;;             (-non-nil
  ;;              ;; -non-nil is necessary because elg--parser
  ;;              ;; returns nil if the entry does not match.
  ;;              ;; Probably should fix this. 
  ;;              (org-ql-select elg:agenda-files
  ;;                `(and (ts :on ,date)
  ;;                      (,type ,item))
  ;;                :action #'elg--parser))))
  ;;     (elg--update-cell-display)))
#+end_src
* New rule creator
** display rule
#+begin_src emacs-lisp :results silent 
  (cl-defmacro elg-create-display-rule (name &key docstring args parser body append disable)
    "NAME is a symbol used to name new functions that are created. 

      ARGS is a list of the text properties that will be used by the function. 
      Any poperties supplied here will be automatically fetched from 
      the cell at point and let-bound for use within BODY. ARGS should consist of only
      those properties that are stored in a calendar cell. If you need to use 
      data that is not contained, you can add a PARSER. 

      PARSER is is used to add information to cells when the
      calendar is generated. It must be an alist in form of ((property-name . body)).
      You may specify a property-name which begins with a colon, or not. If none is 
      provided, a colon will be added automatically. Body is the body of a function 
      that is called when the point is at the first point of each org heading. 
      Its return value will be assigned to the property-name for each cell, and 
      stored as a text property. 

      DOCSTRING is the docstring of the newly-defined function.

      BODY is the body of the display function. DISPLAY-BODY should generally do one
      of the following: Setting an overlay, setting text-properties, changing the face, etc.
      The return value of BODY is ignored and all changes must be made through side-effect. 
      - The face at point can be set with `elg:set-face'.
      - The character of a cell can be changed by using `elg::change-char'.
      - The gradient of a cell, or cells, can be changed with `elg--draw-gradient'.
      - A progress bar can be drawn with `elg--draw-two-color-block'. 

      After the display function is created, it is pushed onto `elg--display-functions'.
      These functions are run for each cell at point, from the start of the list to the 
      end. 

      If APPEND is non-nil, then the function will be appended to the end of
      `elg--display-functions' rather than pushed to the front.p 

      If DISABLE is non-nil, then the rule will be removed from the 
      `elg--display-rules' and any parsing functions created by the rule will
      also be removed."

    (declare (indent defun))
    (let ((display-func-name (intern (concat "elg--display-rule-" (symbol-name name)))))
      `(progn
         (when ',parser
           (cl-loop for (prop . val) in (-list ',parser)
                    do (setf (alist-get (if (s-starts-with-p ":" (symbol-name prop))
                                            prop
                                          (intern (concat ":" (symbol-name prop))))
                                        elg--parsing-functions)
                             `(lambda () ,@val))))
         (if (or ',parser ',args)
             (progn
               (defun ,display-func-name ()
                 ,docstring
                 (mapc
                  (lambda (arg-list)
                    (-let ((,(append (cl-loop for arg in args
                                              collect (elg--colonizer arg t))
                                     (cl-loop for (prop . val) in parser
                                              collect (elg--colonizer prop t)))
                            arg-list))
                      ,@body))
                  (or (elg:zip
                       (mapcar #'elg:get-prop-at-point
                               (append ',(cl-loop for arg in args
                                                  collect (elg--colonizer arg))
                                       ',(cl-loop for (prop . val) in parser
                                                  collect (elg--colonizer prop)))))
                      ;; If the preceding code returns `nil', then the `mapc' function, above,
                      ;; will not run. Since `elg:get-prop-at-point' will usually return nil
                      ;; if on an empty cell, it creates a problem if the user wants to run
                      ;; the command in an empty cell. 
                      ;; To avoid this, if `elg:zip' returns nil, this will create a list of nils to
                      ;; be assigned to the argument list, since nil is not `eq' to (nil),
                      ;; `mapc' will accept the list and run.
                      (make-list (if (> 0 (length (elg:get-prop-at-point))) 
                                     (length (elg:get-prop-at-point))
                                   1)
                                 (make-list (+ (length ',parser) (length ',args)) nil))))))
           (defun ,display-func-name () ,docstring ,@body))
         (if ',append
             (progn
               (setq elg--display-rules (remq ',display-func-name elg--display-rules))
               (add-to-list 'elg--display-rules #',display-func-name t))
           (setq elg--display-rules (remq ',display-func-name elg--display-rules))
           (cl-pushnew #',display-func-name elg--display-rules))
         (when ',disable
           (cl-loop for (name . func) in ',parser
                    do (setq elg--parsing-functions
                             (assq-delete-all name elg--parsing-functions)))
           (setq elg--display-rules (remq ',display-func-name elg--display-rules))))))
#+end_src
*** cell display character
#+begin_src emacs-lisp :results silent 
  (elg-create-display-rule display-char
    :args (elg-deadline elg-timestamp elg-timestamp-ia elg-scheduled elg-timestamp-range)
    :body ((let ((elg-multi (> (length (elg:get-prop-at-point)) 1)))
             (elg::change-char (cond (elg-multi elg-cal-multiple-entry-character)
                                     (elg-deadline  elg-cal-deadline-character)
                                     (elg-timestamp elg-cal-active-timestamp-character)
                                     (elg-timestamp-range
                                      (if (string= (elg:get-date-at-point) (car elg-timestamp-range))
                                          elg-cal-timestamp-range-start-character
                                        elg-cal-timestamp-range-end-character))
                                     (elg-timestamp-ia elg-cal-inactive-timestamp-character)
                                     (elg-scheduled elg-cal-scheduled-character)
                                     (t " "))))))
#+end_src
*** test
#+begin_src emacs-lisp :results silent
  (elg-create-display-rule turn-it-red
    :append t
    :disable t
    :docstring "Turn all deadlines and active timestamps red"
    :parser ((:elg-something . ((buffer-substring (point) (+ 10 (point))))))
    :args (elg-deadline elg-timestamp)
    :body ((when (or elg-deadline elg-timestamp)
             (elg::set-face '(:background "blue") (point) nil 999))))
#+end_src
** actions 
#+begin_src emacs-lisp :results silent 
  (cl-defmacro elg-create-action (name &key docstring parser args body binding)
    "NAME is a symbol used to name new functions that are created. 

     ARGS is a list of the text properties that will be used by the function. 
     Any poperties supplied here will be automatically fetched from 
     the cell at point and let-bound for use within BODY. ARGS should consist of only
     those properties that are stored in a calendar cell. If you need to use 
     data that is not contained, you can add a PARSER. 

     PARSER is is used to add information to cells when the
     calendar is generated. It must be an alist in form of ((property-name . body)).
     You may specify a property-name which begins with a colon, or not. If none is 
     provided, a colon will be added automatically. Body is the body of a function 
     that is called when the point is at the first point of each org heading. 
     Its return value will be assigned to the property-name for each cell, and 
     stored as a text property. 

     DOCSTRING is the docstring of the newly-defined function.

     BODY is the body of a function which performs some action on the underlying
     cell, the underlying org file, or something else. If you need to perform some action
     on the org file, or get data from it, use `elg:with-point-at-orig-entry'. Otherwise,
     action can do anything you'd like. 

     BINDING the key binding for the newly defined ACTION. It allows any
     string accepted by `kbd'."
    (declare (indent defun))
    (let ((action-func-name (intern (concat "elg--action-rule-" (symbol-name name)))))
      `(progn
         (when ',parser
           (cl-loop for (prop . val) in (-list ',parser)
                    do (setf (alist-get (if (s-starts-with-p ":" (symbol-name prop))
                                            prop
                                          (intern (concat ":" (symbol-name prop))))
                                        elg--parsing-functions)
                             `(lambda () ,@val))))
         (if (or ',parser ',args)
             (progn
               (defun ,action-func-name ()
                 ,docstring
                 (interactive)
                 (mapc
                  (lambda (arg-list)
                    (-let ((,(append (cl-loop for arg in args
                                              collect (elg--colonizer arg t))
                                     (cl-loop for (prop . val) in parser
                                              collect (elg--colonizer prop t)))
                            arg-list))
                      ,@body))
               (or (elg:zip
                       (mapcar #'elg:get-prop-at-point
                               (append ',(cl-loop for arg in args
                                                  collect (elg--colonizer arg))
                                       ',(cl-loop for (prop . val) in parser
                                                  collect (elg--colonizer prop)))))
                   ;; If the preceding code returns `nil', then the `mapc' function, above,
                   ;; will not run. Since `elg:get-prop-at-point' will usually return nil
                   ;; if on an empty cell, it creates a problem if the user wants to run
                   ;; the command in an empty cell. 
                   ;; To avoid this, if `elg:zip' returns nil, this will create a list of nils to
                   ;; be assigned to the argument list, since nil is not `eq' to (nil),
                   ;; `mapc' will accept the list and run.
                   (make-list (+ (length ',parser) (length ',args)) nil)))))
           (defun ,action-func-name () ,docstring (interactive) ,@body))
         (when ',binding 
           (define-key elg-mode-map (kbd ,binding) #',action-func-name)))))
#+end_src
*** testing
#+begin_src emacs-lisp :results silent
  (elg-create-action turn-this-shit-red
    :docstring "turn it red when I press O"
    :args (:elg-deadline :elg-headline)
    :body ((elg::create-overlay nil nil 'face '(:background "red") :elg-marker t))
    :binding "o")
#+end_src
* Creating rules
#+begin_src emacs-lisp :results silent
  ;; (cl-defmacro elg--add-rule (&key name args display-body action-body action-binding parser docstring disable)
  ;;   "NAME is a symbol used to name new functions that are created. 

  ;;   ARGS is a list of the text properties that will be used by the function. 
  ;;   Any poperties supplied here will be automatically fetched from 
  ;;   the cell at point and let-bound for use within BODY. ARGS should consist of only
  ;;   those properties that are stored in a calendar cell. If you need to use 
  ;;   data that is not contained, you can add a PARSER. 

  ;;   PARSER is is used to add information to cells when the
  ;;   calendar is generated. It must be an alist in form of ((property-name . body)).
  ;;   You may specify a property-name which begins with a colon, or not. If none is 
  ;;   provided, a colon will be added automatically. Body is the body of a function 
  ;;   that is called when the point is at the first point of each org heading. 
  ;;   Its return value will be assigned to the property-name for each cell, and 
  ;;   stored as a text property. 

  ;;   DOCSTRING is the docstring of the newly-defined function.

  ;;   DISPLAY-BODY is the body of the function, which will be spliced into 
  ;;   the function being created. DISPLAY-BODY should generally do one of the following: 
  ;;   Setting an overlay, setting text-properties, changing the face, etc.
  ;;   The return value of BODY is ignored and all changes must be made through side-effect. 
  ;;   - The face at point can be set with `elg:set-face'.
  ;;   - The character of a cell can be changed by using `elg::change-char'.
  ;;   - The gradient of a cell, or cells, can be changed with `elg--draw-gradient'.
  ;;   - A progress bar can be drawn with `elg--draw-two-color-block'. 

  ;;   After the display function is created, it is inserted into the display function list
  ;;   to be run when finalizing the calendar. 

  ;;   ACTION-BODY is the body of a function which performs some action on the underlying
  ;;   cell, the underlying org file, or something else. If you need to perform some action
  ;;   on the org file, or get data from it, use `elg:with-point-at-orig-entry'. Otherwise,
  ;;   action can do anything you'd like. ACTION-BODY relies on the same arguments

  ;;   ACTION-BINDING the key binding for the newly defined ACTION. It allows any
  ;;   string accepted by `kbd'.

  ;;   Each rule or action will be applied to each entry at the given
  ;;   cell position if there is more than one entry in a cell.

  ;;   If DISABLE is non-nil, then the rule will be deactivated and removed from the 
  ;;   relevant function stacks. To re-enable it, set it to nil or remove it. Note:
  ;;   parsing functions will not be removed even if they are disabled."

  ;;   (declare (indent defun))
  ;;   (let ((display-func-name (intern (concat "elg--display-rule-" (symbol-name name))))
  ;;         (action-func-name (intern (concat "elg--action-rule-" (symbol-name name)))))
  ;;     `(progn
  ;;        (when ',parser
  ;;          (cl-loop for (prop . val) in (-list ',parser)
  ;;                   do (setf (alist-get (if (s-starts-with-p ":" (symbol-name prop))
  ;;                                           prop
  ;;                                         (intern (concat ":" (symbol-name prop))))
  ;;                                       elg--parsing-functions)
  ;;                            `(lambda () ,@val))))
  ;;        (when (and ',name ',action-body)
  ;;          (if (or ',parser ',args)
  ;;              (defun ,action-func-name ()
  ;;                ,docstring
  ;;                (interactive)
  ;;                (mapc
  ;;                 (lambda (arg-list)
  ;;                   (-let ((,(append (cl-loop for arg in args
  ;;                                             collect (if (s-starts-with-p ":" (symbol-name arg))
  ;;                                                         (intern (substring (symbol-name arg) 1))			
  ;;                                                       arg))
  ;;                                    (cl-loop for (prop . val) in parser
  ;;                                             collect (if (s-starts-with-p ":" (symbol-name prop))
  ;;                                                         (intern (substring (symbol-name prop) 1))			
  ;;                                                       prop)))
  ;;                           arg-list))
  ;;                     ,@action-body))
  ;;                 (elg:zip
  ;;                  (mapcar #'elg:get-prop-at-point
  ;;                          (append ',(cl-loop for arg in args
  ;;                                             collect (if (s-starts-with-p ":" (symbol-name arg))
  ;;                                                         arg
  ;;                                                       (intern (concat ":" (symbol-name arg)))))
  ;;                                  ',(cl-loop for (prop . val) in parser
  ;;                                             collect (if (s-starts-with-p ":" (symbol-name prop))
  ;;                                                         prop
  ;;                                                       (intern (concat ":" (symbol-name prop))))))))))
  ;;            (defun ,action-func-name () ,docstring (interactive) ,@action-body))
  ;;          (when ',action-binding 
  ;;            (define-key elg-mode-map (kbd ,action-binding) ',action-func-name)))
  ;;        (when (and ',name ',display-body)
  ;;          (if ',disable
  ;;              (setq elg--display-rules (remove ',display-func-name elg--display-rules))
  ;;            (if (or ',parser ',args)
  ;;                (cl-pushnew
  ;;                 (defun ,display-func-name ()
  ;;                   ,docstring
  ;;                   (mapc
  ;;                    (lambda (arg-list)
  ;;                      (-let ((,(append (cl-loop for arg in args
  ;;                                                collect (if (s-starts-with-p ":" (symbol-name arg))
  ;;                                                            (intern (substring (symbol-name arg) 1))			
  ;;                                                          arg))
  ;;                                       (cl-loop for (prop . val) in parser
  ;;                                                collect (if (s-starts-with-p ":" (symbol-name prop))
  ;;                                                            (intern (substring (symbol-name prop) 1))			
  ;;                                                          prop)))
  ;;                              arg-list))
  ;;                        ,@display-body))
  ;;                    (elg:zip
  ;;                     (mapcar #'elg:get-prop-at-point
  ;;                             (append ',(cl-loop for arg in args
  ;;                                                collect (if (s-starts-with-p ":" (symbol-name arg))
  ;;                                                            arg
  ;;                                                          (intern (concat ":" (symbol-name arg)))))
  ;;                                     ',(cl-loop for (prop . val) in parser
  ;;                                                collect (if (s-starts-with-p ":" (symbol-name prop))
  ;;                                                            prop
  ;;                                                          (intern (concat ":" (symbol-name prop))))))))))
  ;;                 elg--display-rules)
  ;;              (cl-pushnew (defun ,display-func-name () ,docstring ,@display-body)
  ;;                          elg--display-rules)))))))
#+end_src
* Custom rules
** warning dates for deadline
#+begin_src emacs-lisp :results silent 
  ;; (elg--add-rule
  ;;   :name deadline-warning
  ;;   :args (:elg-deadline)
  ;;   :display-body ((when elg-deadline
  ;;                    (save-excursion 
  ;;                      (let ((end (point)))
  ;;                        (elg--goto-date
  ;;                         (elg-date-calc elg-deadline (* -1 elg::deadline-warning-days)))
  ;;                        (elg--draw-gradient "blue" "green" (point) end))))))		

#+end_src
** timerange gradients
#+begin_src emacs-lisp :results silent 
  ;; (elg--add-rule
  ;;   :name time-range-gradient
  ;;   :docstring "Show gradient for active timestamp ranges"
  ;;   :args (elg-timestamp-range)
  ;;   :display-body ((when elg-timestamp-range
  ;;                    (when-let ((start (progn (elg--goto-date (car elg-timestamp-range)) (point)))
  ;;                               (end (progn (elg--goto-date (cadr elg-timestamp-range)) (point))))
  ;;                      (elg::change-char elg-cal-timestamp-range-start-character start)
  ;;                      (elg::change-char elg-cal-timestamp-range-end-character end)
  ;;                      (elg--draw-gradient "red" "blue" start end)))))
#+end_src
** user-controlled gradients
#+begin_src emacs-lisp :results silent 
  ;; (elg--add-rule
  ;;   :name gradient-color-setter
  ;;   :action-body ((elg:with-point-at-orig-entry (elg::select-entry)
  ;;                     (org-set-property "ELG-COLOR-GRADIENT" (concat (s-trim (helm-colors))
  ;;                                                                    " "
  ;;                                                                    (s-trim (helm-colors))))))
  ;;   :action-binding "M-c")
#+end_src 

** deadsync integration
#+begin_src emacs-lisp :results silent
  ;; (setq elg--tag-color-list '(("brief" .     ("black" . "red"))
  ;;                             ("discovery" . ("black" . "blue"))
  ;;                             ("opp_brief" . ("black" . "yellow"))
  ;;                             ("appendix" .  ("black" . "orange"))))

  ;; (setq elg--default-gradient-colors '("black" . "blue"))

  ;; (elg--add-rule
  ;;   :name deadsync
  ;;   :docstring "Show gradient for deadsync-linked headings"
  ;;   :args (elg-alltags)
  ;;   :parser ((org-deadsync-active . ((cdr (car (org-entry-properties (point) "ORG-DEADSYNC-ACTIVE")))))
  ;;            (org-deadsync-link . ((cdr (car (org-entry-properties (point) "ORG-DEADSYNC-LINK"))))))
  ;;   :display-body ((when (and org-deadsync-active
  ;;                             org-deadsync-link)
  ;;                    (when-let ((colors (cl-loop with defined-tags = (mapcar #'car elg--tag-color-list)
  ;;                                                for tag in elg-alltags
  ;;                                                if (elg--mem-s= tag defined-tags)
  ;;                                                return (alist-get tag elg--tag-color-list nil nil #'string=)))
  ;;                               (start (save-excursion (elg::goto-id org-deadsync-link)
  ;;                                                      (point)))
  ;;                               (end (point)))
  ;;                      (elg--draw-gradient (car colors) (cdr colors) start (point))))))
#+end_src 
** Anchor/Dependents module
*** Create anchor
#+begin_src emacs-lisp :results silent
(defun elg:org-create-anchor ()
  "Prompt user for the anchor heading. Add an `org-id' to the 
anchor heading if necessary. Add the property `ELG-ANCHOR'
to the current heading, which is the `org-id' of the anchor.
Add `ELG-DEPENDENTS' to the anchor heading, which is a list
of ids which are anchored to the heading."
  ;;Prompt the user for the offset?
  (let* ((current-heading-id (org-id-get-create))
	 (anchor-heading-id (save-excursion (org-goto)
					    (org-id-get-create))))
    (save-excursion
      (org-id-goto anchor-heading-id)
      (org-set-property "ELG-DEPENDENTS"
 (cdar (org-entry-properties
				       (point)
				       "ELG-DEPENDENTS"))
				" "
				current-heading-id)))
    (org-set-property "ELG-ANCHOR" anchor-heading-id)))
#+end_src
*** Get dependents
#+begin_src emacs-lisp :results silent
(defun elg::org-get-dependents ()
  "Return a list of dependent deadlines from an org buffer."
  (when-let ((anchors (cdar (org-entry-properties (point) "ELG-DEPENDENTS"))))
    (s-split " " anchors)))
#+end_src
*** Get dependents at point
#+begin_src emacs-lisp :results silent
  (defun elg::get-dependents (&optional props)
    "Get a list of dependents from the cell at point.
  If PROPS, get the dependent from those properties. If
  PROPS is `all', then get all dependents at point if there
  are multiple entries in the cell." 
    (when-let ((prop (or (when (eq props 'all)
                           (elg::select-entry 'all))
                         (when props
                           (list props))
                         (list (elg::select-entry))))
               (dependents (mapcar (lambda (p)
                                     (plist-get p :ELG-DEPENDENTS))
                                   prop)))
      (unless (eq (-non-nil dependents) nil)
        (s-split " " (cl-loop for dep in (-flatten dependents)
                              concat dep)))))
#+end_src
*** Highlight dependents
#+begin_src emacs-lisp :results silent
  (defun elg::highlight-dependents ()
    (interactive)
    (elg::highlight-dependent-dates 'elg:dependent-highlight))

    (defun elg::highlight-dependent-dates (face &optional props)
      "Apply FACE to all dependant dates of the current date at point."
      (save-excursion 
        (if-let ((dependents (elg::get-dependents props)))
            (progn (elg::set-face face)
                   (mapc (lambda (dependent-id)
                           (elg::goto-id dependent-id)
                           (elg::set-face face))
                         dependents))
          (elg::clear-elg-overlays))))
#+end_src
*** Shift date and dependents
#+begin_src emacs-lisp :results silent
  (defun elg::move-date-and-dependents (&optional backward props)
    "Move the current date and all anchored dates (and their dependents) forward by one days
  If BACKWARD is non-nil, move backward. PROPS is a plist of cell data; otherwise,
  use the cell at point and prompt the user if there are multiple entries in the cell."
    (interactive)
    (when-let* ((props (if backward
                           (elg::shift-date -1 props)
                         (elg::shift-date 1 props)))
                (dependent-ids (elg::get-dependents props)))
      (mapc (lambda (dependent-id)
              (save-excursion
                (elg::goto-id dependent-id)
                (let ((new-props (-first (lambda (x)
                                           (-contains? x dependent-id))
                                         (elg:get-prop-at-point))))
                  (if backward
                      (elg::move-date-and-dependents 'backward new-props)
                    (elg::move-date-and-dependents nil new-props)))))
            dependent-ids)))

  (defun elg:move-date-and-dependents-forward ()
    (interactive)
    (elg::move-date-and-dependents))

  (defun elg:move-date-and-dependents-backward ()
    (interactive)
    (elg::move-date-and-dependents 'backward))
#+end_src 
* org-super-agenda conversion
#+begin_src emacs-lisp :results silent
  (defun elg--convert-super-agenda ()
"Convert your super agenda view into a horizontal calendar
using the super agenda headers as the calendar headers."
    (goto-char (point-min))
    (with-current-buffer "*El Gantt Calendar*"
      (setq elg::date-range nil)
      (setq elg--hidden-overlays nil)  
      (erase-buffer)
      (elg::draw-month-line)
      (insert "\n")
      (elg::draw-number-line))
      (cl-loop do (progn (next-line)
                       (cond ((eq (get-text-property (point) 'face) 'org-super-agenda-header)
                              (let ((string (s-trim (buffer-substring-no-properties (point-at-bol)
                                                                                    (point-at-eol)))))
                                (with-current-buffer "*El Gantt Calendar*"
                                  (elg::get-header-create string))))
                             ((get-text-property (point) 'org-marker)
                              (let ((props (org-agenda-with-point-at-orig-entry nil (elg--parser))))
                                (with-current-buffer "*El Gantt Calendar*" 
                                  (elg::insert-entry props))))))
             until (eobp))
    (switch-to-buffer "*El Gantt Calendar*")
    (elg-mode)
    (read-only-mode -1)
    (toggle-truncate-lines 1)
    (elg--draw-display)
    (elg--highlight-current-day)
    (setq header-line-format elg-header-line-format))
#+end_src 
* Open function
#+begin_src emacs-lisp :results silent 
  (defun elg:open ()
    (interactive)
    (switch-to-buffer "*El Gantt Calendar*")
    (let ((point (point)))
      (setq elg::date-range nil)
      (setq elg--hidden-overlays nil)
      (erase-buffer)
      (insert (make-string elg:header-column-offset ? )
              "\n"
              (make-string elg:header-column-offset ? ))
      (elg--iterate)
      (elg-mode)
      (elg--draw-display)
      (elg--highlight-current-day)
      (goto-char point)))
#+end_src
* Interaction module
#+begin_src emacs-lisp :results silent 
  ;;;  -*- lexical-binding: t; -*-
  (setq elgantt-interaction::action-list nil)
  (setq elgantt-interaction::selected-cells nil)
  (setq elgantt-interaction::current-action nil)
  (setq elgantt-interaction::message-overlay nil)

  (defun elgantt-interaction::adjust-overlay ()
    (interactive)
    (when elgantt-interaction::message-overlay
      (let* ((start (save-excursion (move-to-window-line 0) (point)))
             (end (+ start (length (overlay-get elgantt-interaction::message-overlay
                                                'display)))))
        (move-overlay elgantt-interaction::message-overlay
                      start
                      end))))

  (defun elgantt-interaction::message-overlay (command &optional string)
    (pcase command
      ((or `delete `clear) (progn (ov-clear :elg-interaction-message)
                                  (setq elgantt-interaction::message-overlay nil)))
      ((or `set `create) (let* ((message (concat "INTERACTION MODE: " (symbol-name elgantt-interaction::current-action)
                                                 "  " string "  "
                                                 (number-to-string
                                                  (length elgantt-interaction::selected-cells))
                                                 " of "
                                                 (number-to-string
                                                  (elgantt-interaction::get-prop elgantt-interaction::current-action
                                                                                 :selection-number))))		       
                                (start (save-excursion (move-to-window-line 0) (point)))
                                (end (+ start (length message))))
                           (elgantt-interaction::message-overlay 'clear)
                           (setq elgantt-interaction::message-overlay
                                 (make-overlay start end))
                           (overlay-put elgantt-interaction::message-overlay
                                        'display message)
                           (overlay-put elgantt-interaction::message-overlay
                                        :elg-interaction-message t)
                           (overlay-put elgantt-interaction::message-overlay
                                        'face
                                        'elgantt-interaction::message-bar-face)))))

  (defun elgantt-interaction::get-message ()
    (let* ((number-selected (1+ (length elgantt-interaction::selected-cells)))
           (message-stack (elgantt-interaction::get-prop elgantt-interaction::current-action
                                                         :selection-messages))
           (places (cl-loop for place in message-stack
                            collect (car place)))
           (max-selections (elgantt-interaction::get-prop elgantt-interaction::current-action
                                                          :selection-number)))
      (cond ((memq 'all places)
             (alist-get 'all message-stack))
            ((memq number-selected places)
             (alist-get number-selected message-stack))
            ((and (= number-selected max-selections)
                  (memq 'last places))
             (alist-get 'last message-stack))
            ((and (<= number-selected max-selections)
                  (memq 'rest places))
             (alist-get 'rest message-stack)))))

  (defun elgantt-interaction::start-action ()
     (interactive)
    (setq elgantt-interaction::selected-cells nil)
    (setq elgantt-interaction::current-action nil)
    (when-let ((action (intern (completing-read "Select action: "
                                                (mapcar (lambda (element)
                                                          (symbol-name (car element)))
                                                        elgantt-interaction::action-list) 
                                                nil t))))
      (setq elgantt-interaction::current-action action)
      (elgantt-interact-mode 1)
      (elgantt-interaction::message-overlay
       'set
       (elgantt-interaction::get-message))))


  (defun elgantt-interaction::get-prop (name prop)
    (plist-get (alist-get name elgantt-interaction::action-list) prop))

  (defun elgantt-interaction::add-cell-to-list ()
    (interactive)
    (if (<= (length elgantt-interaction::selected-cells) (elgantt-interaction::get-prop
                                                          elgantt-interaction::current-action
                                                          :selection-number))
        (progn 
          (setq elgantt-interaction::selected-cells
                (append elgantt-interaction::selected-cells
                        `(,(elg::select-entry))))
          (elgantt-interaction::message-overlay 'set
                                                (elgantt-interaction::get-message)))
      (message "Too many cells selected!")))

  (defsubst elgantt-interaction::terminate ()
    (interactive)
    (elgantt-interact-mode -1))

  (define-minor-mode elgantt-interact-mode
    "Mode to interact with calendar"
    nil
    "ELG-INTERACT"
    (let ((map (make-sparse-keymap)))
      (set-keymap-parent map elg-mode-map)
      (define-key map (kbd "RET") #'elgantt-interaction::execute-action)
      (define-key map (kbd "q") #'elgantt-interaction::terminate)
      (define-key map (kbd "SPC") #'elgantt-interaction::add-cell-to-list)
      map)
    (if elgantt-interact-mode
        (progn (setq cursor-type 'hollow)
               (elgantt-interaction::message-overlay 'delete)
               ;;(add-hook 'post-command-hook #'elgantt-interaction::adjust-overlay t t)
               (setq elgantt-interaction::selected-cells nil))
      (setq cursor-type 'box)
      (elgantt-interaction::message-overlay 'delete)
      (setq elgantt-interaction::selected-cells nil)
      ;;(remove-hook 'post-command-hook #'elgantt-interaction::adjust-overlay t)
      (setq elgantt-interaction::current-action nil)))

  (cl-defmacro elg--selection-rule (&key name selection-number selection-messages execution-functions args parser)
    ;; NOTE: There is no need for this to be a macro, except to avoid quoting in the
    ;; call. 
    (when execution-functions
      (let (function-stack)
        (if (or parser args)
            (cl-loop for (place . command) in execution-functions
                     do (push `(,place . (lambda (return-val)
                                           (mapc
                                            (lambda (arg-list)
                                              (-let ((,(append (cl-loop for arg in args
                                                                        collect (elg--colonizer arg t))
                                                               (cl-loop for (prop . val) in parser
                                                                        collect (elg--colonizer prop t)))
                                                      arg-list))
                                                ,@command))
                                            (or 
                                             (elg:zip
                                              (mapcar #'elg:get-prop-at-point
                                                      (append (cl-loop for arg in args
                                                                       collect (elg--colonizer arg))
                                                              (cl-loop for (prop . val) in parser
                                                                       collect (elg--colonizer prop)))))
                                             ;; If the preceding code returns `nil', then the `mapc' function, above,
                                             ;; will not run. Since `elg:get-prop-at-point' will usually return nil
                                             ;; if on an empty cell, it creates a problem if the user wants to run
                                             ;; the command in an empty cell. 
                                             ;; To avoid this, if `elg:zip' returns nil, this will create a list of nils to
                                             ;; be assigned to the argument list, since nil is not `eq' to (nil),
                                             ;; `mapc' will accept the list and run.
                                             (make-list (+ (length ',parser) (length ',args)) nil)))))
                              function-stack))
          (cl-loop for (place . command) in execution-functions
                   do (push `(,place . (lambda (return-val) ,@command)) function-stack)))
        `(setf (alist-get ',name elgantt-interaction::action-list) (list :execution-functions ',function-stack
                                                                         :selection-number ,(if (= selection-number 0)
                                                                                                999
                                                                                              selection-number)
                                                                         :selection-messages ',selection-messages)))))

  (defun elgantt-interaction::execute-action ()
    (interactive)
    (let ((function-stack (reverse (plist-get
                                    (alist-get elgantt-interaction::current-action elgantt-interaction::action-list)
                                    :execution-functions)))
          return-val)
      (cl-loop for (place . function) in function-stack
               do (pcase place
                    ((pred numberp) (progn (elg::goto-id (plist-get (nth (1- place) elgantt-interaction::selected-cells) :ID))
                                           (setq return-val (funcall function return-val))))
                    (`all (mapc (lambda (cell)
                                  (elg::goto-id (plist-get cell :ID))
                                  (setq return-val (funcall function return-val))))
                          elgantt-interaction::selected-cells)
                    (`rest (mapc (lambda (cell)
                                   (elg::goto-id (plist-get elgantt-interaction::selected-cells :ID))
                                   (funcall-function return-val))
                                 (cdr elgantt-interaction::selected-cells)))
                    (`all-but-last (mapc (lambda (cell)
                                           (elg::goto-id (plist-get cell :ID))
                                           (setq return-val (funcall function return-val))))
                                   (butlast elgantt-interaction::selected-cells))
                    (`last (progn (elg::goto-id (plist-get (last elgantt-interaction::selected-cells) :ID))
                                  (setq return-val (funcall function return-val))))))
      (elgantt-interact-mode -1)))

  (elg--selection-rule :name set-anchor
                       :execution-functions ((2 . ((elg:with-point-at-orig-entry nil
                                                       (org-id-get-create))))
                                             (1 . ((elg:with-point-at-orig-entry nil
                                                       (let ((current-heading-id (org-id-get-create)))
                                                         (org-set-property "ELG-DEPENDENTS"
                                                                           (concat (cdar (org-entry-properties
                                                                                          (point)
                                                                                          "ELG-DEPENDENTS"))
                                                                                   " "
                                                                                   return-val))
                                                         current-heading-id))))
                                             (2 . ((elg:with-point-at-orig-entry nil
                                                       (org-set-property "ELGANTT-ANCHOR" return-val)))))
                       :selection-messages ((1 . "Select the anchor.")
                                            (rest . "Select the dependents."))
                       :selection-number 0)
#+end_src
* Testing
** It's a race!
#+begin_src emacs-lisp
  (defun elg:get-data-org-map ()
    "Testing function." 
    (-non-nil
     (org-map-entries #'elg--parser
                      nil
                      (-list elg:agenda-files)
                      elg:skip-files)))

  (defun elg:get-data-org-ql ()
    "Testing function."
    (-non-nil
     (org-ql-select elg:agenda-files
       '(and (ts)
             (not (tags "ARCHIVE")))
       :action #'elg--parser)))

  (defun elg:get-data-org-map-pre ()
    "Testing function." 
    (-non-nil
     (org-map-entries (lambda () (-let (((&alist "TIMESTAMP" elg-timestamp
                                                 "TIMESTAMP_IA" elg-timestamp-ia
                                                 "DEADLINE" elg-deadline
                                                 "SCHEDULED" elg-scheduled)
                                         (org-entry-properties)))
                                   (when (or elg-timestamp
                                             elg-timestamp-ia
                                             elg-deadline
                                             elg-scheduled)
                                     (elg--parser))))
                      nil
                      (-list elg:agenda-files)
                      elg:skip-files)))

  (defun elg:get-data-org-map-pre* ()
    "Testing function." 
    (-non-nil
     (org-map-entries (lambda ()
                        (let ((props (org-entry-properties)))
                          (when (or (alist-get "TIMESTAMP" props nil nil #'string=)
                                    (alist-get "TIMESTAMP_IA" props nil nil #'string=)
                                    (alist-get "DEADLINE" props nil nil #'string=)
                                    (alist-get "SCHEDULED" props nil nil #'string=))
                            (elg--parser))))
                      nil
                      (-list elg:agenda-files)
                      elg:skip-files)))

  (bench-multi :times 100 :ensure-equal t
    :forms (("org-map" (elg:get-data-org-map))
            ("org-map-preprocess" (elg:get-data-org-map-pre))
            ("org-map-preprocess*" (elg:get-data-org-map-pre*))
            ("org-ql" (elg:get-data-org-ql))))
#+end_src

#+RESULTS:
| Form                | x faster than next | Total runtime | # of GCs | Total GC runtime |
|---------------------+--------------------+---------------+----------+------------------|
| org-ql              |              14.94 |      0.134995 |        1 |         0.058762 |
| org-map-preprocess* |               1.19 |      2.017357 |       15 |         0.951616 |
| org-map-preprocess  |               1.04 |      2.403705 |       20 |         1.184456 |
| org-map             |            slowest |      2.490510 |       21 |         1.261543 |

* Recycling

