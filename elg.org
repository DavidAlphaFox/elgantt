* Lexical binding
#+begin_src emacs-lisp :results silent
;;; -*- lexical-binding: t; -*-
#+end_src
* Requirements
#+begin_src emacs-lisp :results silent
(require 'cl-lib)
(require 'color)
(require 'org)
(require 'org-ql)
(require 's)
(require 'dash)
(require 'ts)
#+end_src
* Faces
#+begin_src emacs-lisp :results silent
(defface elg:horizontal-line-face
  '((t :background "white" :foreground "white" :height .1))
  "Horizontal line face")

(defface elg:vertical-line-face
  '((t :background "white" :foreground "white" :height .1))
  "Vertical line face")

(defface elg:dependent-highlight
  '((t (:background "white" :foreground "white")))
  "dependent highlight face")

(defun elgnatt:set-vertical-bar-face ()
  (goto-char (point-min))
  (while (re-search-forward elg:vertical-line-char nil t)
    (put-text-property (match-beginning 0)
		       (match-end 0)
		       'face
		       'elg-vertical-line-face)))
#+end_src
* Internal variables
** Layout variables
#+begin_src emacs-lisp :results silent
(defconst elg:leap-year-month-line   "| January xxxx                  | February xxxx               | March xxxx                    | April xxxx                   | May xxxx                      | June xxxx                    | July xxxx                     | August xxxx                   | September xxxx               | October xxxx                  | November xxxx                | December xxxx                 ")
(defconst elg:leap-year-date-line    "|1234567890123456789012345678901|12345678901234567890123456789|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901")
(defconst elg:leap-year-blank-line   "|                               |                             |                               |                              |                               |                              |                               |                               |                              |                               |                              |                               ")
(defconst elg:normal-year-month-line "| January xxxx                  | February xxxx              | March xxxx                    | April xxxx                   | May xxxx                      | June xxxx                    | July xxxx                     | August xxxx                   | September xxxx               | October xxxx                  | November xxxx                | December xxxx                 ")
(defconst elg:normal-year-date-line  "|1234567890123456789012345678901|1234567890123456789012345678|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901|123456789012345678901234567890|1234567890123456789012345678901")
(defconst elg:normal-year-blank-line "|                               |                            |                               |                              |                               |                              |                               |                               |                              |                               |                              |                               ")
(defconst elg:vertical-line-char "|")
(put-text-property 0 1 'face 'elg:vertical-line-face elg:vertical-line-char)
(defmacro elg::add-vertical-line-props (lines)
  (let ((body (cl-loop for line in lines
		       collect `(setq ,line (s-replace "|" ,elg:vertical-line-char ,line)))))
    `(progn ,@body)))
(elg::add-vertical-line-props (elg:leap-year-month-line
				   elg:leap-year-date-line
				   elg:leap-year-blank-line
				   elg:normal-year-month-line
				   elg:normal-year-date-line
				   elg:normal-year-blank-line))
#+end_src 
** More variables
#+begin_src emacs-lisp :results silent 
(defvar elg::date-range nil
  "Range of years to be calendared. Default: `elg::get-years'")

(defcustom elg:header-column-offset 20
  "Width of the header column")
(defvar elg::deadline-warning-days org-deadline-warning-days
  "Warning days to show in calendar.")
#+end_src
* Custom variables
** Display customization
#+begin_src emacs-lisp :results silent

  ;; (defvar elg--character-rules '(("▲" . (lambda ()  ))
  ;; 			       ("●" . (lambda ()))
  ;; 			       ("⊚" . (lambda ()))
  ;; 			       ("⬟" . (lambda ()))
  ;; 			       ("☰" . (lambda ()))))


  (defcustom elg-cal-deadline-character "▲"
    "Character used for deadlines in the calendar.")

  (defcustom elg-cal-active-timestamp-character "●"
    "Character used for active timestamps in the calendar")

  (defcustom elg-cal-inactive-timestamp-character "⊚"
    "Character used for inactive timestamps in the calendar")

  (defcustom elg-cal-scheduled-character "⬟"
    "Character used for active timestamps in the calendar")

  (defcustom elg-cal-multiple-entry-character "☰"
    "Character used for cells which have multiple entries")

  (setq elg:cell-entry-re (concat "["
                                        elg-cal-deadline-character
                                        elg-cal-active-timestamp-character
                                        elg-cal-inactive-timestamp-character
                                        elg-cal-scheduled-character
                                        elg-cal-multiple-entry-character
                                        "]"))
#+end_src 
** Agenda file customization
#+begin_src emacs-lisp :results silent
(defcustom elg:agenda-files (org-agenda-files)
  "Source files. Default: `org-agenda-files'.")
(setq elg:agenda-files "~/.emacs.d/lisp/elgantt/TEST/sample-work.org")
(setq elg:agenda-files "~/.emacs.d/lisp/elgantt/TEST/sample.org")
;;(setq elg:agenda-files "~/Dropbox/DropsyncFiles/taskmaster.org")

(defcustom elg:skip-files 'archive
  "Accepts the following values from `org-map-entries'):
`archive'    skip trees with the archive tag
`comment'    skip trees with the COMMENT keyword
`function' or Emacs Lisp form:
           will be used as value for org-agenda-skip-function, so
           whenever the function returns a position, FUNC will not be
           called for that entry and search will continue from the
           position returned")
#+end_src
** Header type
#+begin_src emacs-lisp :results silent
(defcustom elg:header-type 'root
  "Define how to gather the headers")
#+end_src
** Parsing functions
#+begin_src emacs-lisp :results silent
  (defvar elg--parsing-functions nil
    "List of functions for parsing org files.")
#+end_src
** display rules
#+begin_src emacs-lisp :results silent
  (defvar elg--display-rules nil
    "List of functions for drawing overlays in the buffer based on underlying text properties.")
#+end_src
* Utility functions
** List utilities
*** elg-zip
#+begin_src emacs-lisp
  (defun elg:zip (args)
    "Zips multiple lists together. Example:
    (elg:zip '((1 5 9) (2 6 10) (3 7 11) (4 8 12)))
     => '((1 2 3 4) (5 6 7 8) (9 10 11 12)).
    All lists must be the same length."
    (if (catch 'match
          (dotimes (x (1- (length args)))
            (when (/= (length (nth x args))
                      (length (nth (1+ x) args)))
              (throw 'match nil)))
          (throw 'match t))
        (let (zip subzip)
          (dotimes (_ (length (car args)))
            (setq subzip nil)
            (dotimes (x (length args))
              (push (pop (nth x args)) subzip))
            (push (reverse subzip) zip))
          (reverse zip))
      (user-error "Lists are not all the same length.")))
#+end_src

#+RESULTS:
: elg:zip

** Getters
*** Get header at point
#+begin_src emacs-lisp :results silent
(defun elg:get-header-at-point ()
  (save-excursion
    (beginning-of-line)
    (get-text-property (point) 'elg-header)))
#+end_src
*** Get dependents at point
#+begin_src emacs-lisp :results silent
  (defun elg::get-dependents (&optional props)
    "Get a list of dependents from the cell at point.
  If PROPS, get the dependent from those properties. If
  PROPS is `all', then get all dependents at point if there
  are multiple entries in the cell." 
    (when-let ((prop (or (when (eq props 'all)
                           (elg::select-entry 'all))
                         (when props
                           (list props))
                         (list (elg::select-entry))))
               (dependents (mapcar (lambda (p)
                                     (plist-get p :elg-dependents))
                                   prop)))
      (unless (eq (-non-nil dependents) nil)
        (s-split " " (cl-loop for dep in (-flatten dependents)
                              concat dep)))))
#+end_src
*** Get date at point
#+begin_src emacs-lisp :results silent
(defun elg:get-date-at-point (&optional column)
  "Get the date at point in YYYY-MM-DD format."
  ;; This is ugly and written when just beginning
  ;; to learn Emacs/coding. 
  (if (not (char-equal (char-after) ?|))
      (progn
	(when (not column)
	  (setq column (current-column)))
	(let ((current-point (point))
	      (date ""))
	  (save-excursion
	    (if (re-search-backward "|" nil t)
		(progn 
		  (setq date (number-to-string (- current-point (match-beginning 0))))
		  (with-no-warnings (goto-line 0))
		  (move-to-column column)
		  (if (re-search-backward "|" nil t)
		      (progn
			(re-search-forward "[[:alpha:]]+" nil t)
			(setq date (concat (match-string 0) " " date))
			(if (re-search-forward "[[:digit:]]+" nil t)
			    (progn
			      (setq date (concat date ", " (match-string 0)))
			      (let ((day (org-day-of-week (nth 3 (parse-time-string date))
							  (nth 4 (parse-time-string date))
							  (nth 5 (parse-time-string date))))
				    (text ""))
				(cond ((= day 0) (setq text "Monday, "))
				      ((= day 1) (setq text "Tuesday, "))
				      ((= day 2) (setq text "Wednesday, "))
				      ((= day 3) (setq text "Thursday, "))
				      ((= day 4) (setq text "Friday, "))
				      ((= day 5) (setq text "Saturday, "))
				      ((= day 6) (setq text "Sunday, ")))
				(setq date (concat text date))))
			  (setq date "")))
		    (setq date "")))
	      (setq date "")))
	  date))
    ""))
#+end_src
*** Get property at point
#+begin_src emacs-lisp :results silent
  (defun elg:get-prop-at-point (&optional prop)
    "Returns all text properties at point. If a property is 
  specified, then return that property for each entry at point if 
  there are multiple entries."
    (let ((prop-list (plist-get (text-properties-at (point)) :elg)))
      (if prop
          (mapcar (lambda (props) (plist-get props prop))
                  prop-list)
        prop-list)))



#+end_src
** Goto functions
*** Goto next
#+begin_src emacs-lisp :results silent
  (defsubst elg--goto-next ()
    (elg::move-selection-bar-forward))

  (defsubst elg--goto-previous
    (elg::move-selection-bar-backward))
#+end_src
*** Goto date
#+begin_src emacs-lisp :results silent
  (defun elg--goto-date (date)
    "Go to DATE in the current header."
    (beginning-of-line)
    (forward-char 
     (elg::convert-date-to-column-number date)))
#+end_src
*** Goto ID
#+begin_src emacs-lisp :results silent
(defun elg::goto-id (id)
  "Go to the cell for the org entry with ID. Return nil if not found."
  ;; Note: we cannot use `text-property-any' to find the value because
  ;; comparisons are done using `eq' which will not work for string values.
  (when-let ((point (cl-loop for points being the intervals of (current-buffer) property :elg
			     thereis (save-excursion
				       (goto-char (car points))
				       (let ((props (elg:get-prop-at-point)))
					 (when (-first (lambda (x)
							 (-contains? x id))
						       props)
					   (car points)))))))
    (goto-char point)))
#+end_src
** Misc utilities
#+begin_src emacs-lisp :results silent
(defun elg::convert-date-to-column-number (timestamp)
  "Accepts a date in the form of \"YYYY-MM-DD\" and returns
the column of that date."
  (let ((spaces 0)
	(date timestamp))
    (cl-subseq elg::date-range
	       0 (cl-position (string-to-number (substring date 0 4)) elg::date-range))
    ;; add the preceding years
    (dolist (year
	     (cl-subseq elg::date-range
			0 (cl-position (string-to-number (substring date 0 4)) elg::date-range)))
      (if (elg::leap-year-p year)
	  (setq spaces (+ spaces 366 12))
	(setq spaces (+ spaces 365 12))))
    ;; add the current year
    (+ spaces (elg::convert-date-to-column-in-current-year date) elg:header-column-offset)))

(defun elg::convert-date-string-to-day-number-in-year (date)
  "accept a date in the format YYYY-MM-DD and return an int of day number of the year"
  (time-to-day-in-year (encode-time 0 0 0 (string-to-number (substring date 8 10))
				    (string-to-number (substring date 5 7))
				    (string-to-number (substring date 0 4)))))

(defun elg::convert-date-to-column-in-current-year (date)
  "accepts a date YYYY-MM-DD and returns the position on the horizontal calendar (int)
this works on leap years"
  (+ (elg::convert-date-string-to-day-number-in-year date)
     (- (string-to-number (substring date 5 7)) 1)))

(defsubst elg::get-days-in-year (year)
  "Return the number of days in YEAR." 
  (if (elg::leap-year-p year) 366 365))

(defsubst elg::leap-year-p (year)
  "Return t if YEAR is a leap year. Otherwise, nil."
  (= (% year 4) 0))

#+end_src
** Org buffer functions
*** Create anchor
#+begin_src emacs-lisp :results silent
(defun elg:org-create-anchor ()
  "Prompt user for the anchor heading. Add an `org-id' to the 
anchor heading if necessary. Add the property `ELG-ANCHOR'
to the current heading, which is the `org-id' of the anchor.
Add `ELG-DEPENDENTS' to the anchor heading, which is a list
of ids which are anchored to the heading."
  ;;Prompt the user for the offset?
  (let* ((current-heading-id (org-id-get-create))
	 (anchor-heading-id (save-excursion (org-goto)
					    (org-id-get-create))))
    (save-excursion
      (org-id-goto anchor-heading-id)
      (org-set-property "ELG-DEPENDENTS"
			(concat (cdar (org-entry-properties
				       (point)
				       "ELG-DEPENDENTS"))
				" "
				current-heading-id)))
    (org-set-property "ELG-ANCHOR" anchor-heading-id)))
#+end_src
*** Get dependents
#+begin_src emacs-lisp :results silent
(defun elg::org-get-dependents ()
  "Return a list of dependent deadlines from an org buffer."
  (when-let ((anchors (cdar (org-entry-properties (point) "ELG-DEPENDENTS"))))
    (s-split " " anchors)))
#+end_src
** On vertical line
#+begin_src emacs-lisp :results silent
(defun elg::on-vertical-line ()
  (string= "|" (buffer-substring (point) (1+ (point)))))
#+end_src
** Get date range
#+begin_src emacs-lisp :results silent
(cl-defun elg::get-years (&optional (date-type '(all)))
  "Get the date range of all time values in all agenda files. 
Optional DATE-TYPE is any value (or list of values) accepted by `org-re-timestamp':
        all: all timestamps
     active: only active timestamps (<...>)
   inactive: only inactive timestamps ([...])
  scheduled: only scheduled timestamps
   deadline: only deadline timestamps
     closed: only closed time-stamps
If it is not provided, the default is `all'."
  (save-excursion
    (let ((years '()))
      (--each (-list elg:agenda-files)
	(with-temp-buffer
	  (insert-file-contents it)
	  (goto-char (point-min))
	  (--each (or (-list date-type)
		      '(all))
	    (goto-char (point-min))
	    (while (re-search-forward (org-re-timestamp it) nil t)
	      (push (substring (car (s-split "-" (match-string 0))) 1) years)))))
      (delete-dups years)
      (sort
       (mapcar (lambda (it)
		 (string-to-number it))
	       years)
       '<))))
#+end_src
** Get display character
#+begin_src emacs-lisp :results silent
(defun elg::get-display-char (type)
  "Get the character to insert."
  (pcase type
    ('deadline elg-cal-deadline-character)
    ('timestamp elg-cal-active-timestamp-character)
    ('timestamp-ia elg-cal-inactive-timestamp-character)
    ('multiple elg-cal-multiple-entry-character)
    ('scheduled elg-cal-scheduled-character)))
#+end_src
** Getting data
*** Get data from cell
#+begin_src emacs-lisp :results silent
  (defun elg::select-entry (&optional prop-or-all val)
    "Prompt the user to select from multiple entries.
  If PROP is `all', then return the list of all props at point."
    (when-let ((prop-list (elg:get-prop-at-point)))
      (cond ((eq prop-or-all 'all)
             ;; If user wants all entries, return them
             prop-list)
            ((= (length prop-list) 1)
             ;; If there is only one entry, return it,
             ;; but flatten the list.
             ;; If there are two entries, it will return
             ;; a nested list; if there is one entry,
             ;; the list is not nested. 
             (car prop-list))
            (t
             ;; Otherwise, there are more than one entry
             ;; and the user only wants one of them.
             ;; Prompt the user to select which one. 
             (let ((selection (completing-read "Select entry: "
                                               (elg:get-prop-at-point :raw-value)
                                               nil
                                               'require-match)))
               (-first (lambda (x) (-contains? x selection)) prop-list))))))
#+end_src
** Refreshing
*** Run org-ql for date at point
#+begin_src emacs-lisp :results silent
(defun elg::run-org-ql-for-date-at-point ()
  (interactive)
  (when-let* ((date (elg:get-date-at-point))
	      (type (pcase elg:header-type
		      ('root 'ancestors)
		      ('category 'category)
		      ('hashtag 'tags-inherited)))
	      (header (elg:get-header-at-point))
	      (item (pcase type
		      ('category header)
		      ('hashtag header)
		      ('ancestors `(regexp ,header)))))
    (org-ql-select elg:agenda-files
      `(and (ts :on ,date)
	    (,type ,item))
      :action #'elg--parser)))
#+end_src
*** Update this cell
#+begin_src emacs-lisp :results silent
  (defun elg:update-this-cell ()
    "Gets data for a specific cell by looking for any headings
  which occur on the operative date."
    (when (elg::on-vertical-line)
      (user-error "Error in elg:update-this-cell: Not on a calendar cell."))
    ;; I don't know why I am saving this excursion.
    (save-excursion 
      (delete-char 1)
      (insert " ")
      (backward-char)
      (when-let* ((date (elg:get-date-at-point))
                  (type (pcase elg:header-type
                          ('root 'ancestors)
                          ('category 'category)
                          ('hashtag 'tags-inherited)))
                  (header (elg:get-header-at-point))
                  (item (pcase type
                          ('category header)
                          ('hashtag header)
                          ('ancestors `(regexp ,header)))))
        (mapc #'elg::insert-entry
              (-non-nil
               ;; -non-nil is necessary because elg--parser
               ;; returns nil if the entry does not match.
               ;; Probably should fix this. 
               (org-ql-select elg:agenda-files
                 `(and (ts :on ,date)
                       (,type ,item))
                 :action #'(elg--parser)))))))
#+end_src
** Normalize date strings
#+begin_src emacs-lisp :results silent
(defun elg::convert-date-string (date-string)
  "Converts an org date string to YYYY-MM-DD."
  (ts-format "%Y-%m-%d" (ts-parse-org date-string)))
#+end_src
* Interaction functions
** Shift date at point
#+begin_src emacs-lisp :results silent
  (defun elg::shift-date (n &optional properties)
    "Move the timestamp up or down by one day.
  N should be 1 or -1. The return value
  is the prop list of the entry that has been moved."
    ;; Moving by single day is the easiest way to handle this,
    ;; rather than moving by week or month, etc. 
    (unless (or (= n 1)
                (= n -1))
      (error "elg::shift-date: Invalid argument. N must be 1 or -1."))
    (let ((props (or properties
                     (elg::select-entry))))
      (elg:with-point-at-orig-entry props
          (when (re-search-forward (org-re-timestamp 'all))
            (org-timestamp-change n 'day)))
      (elg:update-this-cell)
      (pcase n
        (1  (elg::move-horizontally 1)
            (elg:update-this-cell))
        (-1 (elg::move-horizontally -1)
            (elg:update-this-cell)))
      props))

  (defsubst elg::shift-date-forward ()
    (interactive)
    (elg::shift-date 1))

  (defsubst elg::shift-date-backward ()
    (interactive)
    (elg::shift-date -1))

#+end_src
*** Shift date and dependents
#+begin_src emacs-lisp :results silent
  (defun elg::move-date-and-dependents (&optional backward props)
    "Move the current date and all anchored dates (and their dependents) forward by one days
  If BACKWARD is non-nil, move backward. PROPS is a plist of cell data; otherwise,
  use the cell at point and prompt the user if there are multiple entries in the cell."
    (interactive)
    (when-let* ((props (if backward
                           (elg::shift-date -1 props)
                         (elg::shift-date 1 props)))
                (dependent-ids (elg::get-dependents props)))
      (mapc (lambda (dependent-id)
              (save-excursion
                (elg::goto-id dependent-id)
                (let ((new-props (-first (lambda (x)
                                           (-contains? x dependent-id))
                                         (elg:get-prop-at-point))))
                  (if backward
                      (elg::move-date-and-dependents 'backward new-props)
                    (elg::move-date-and-dependents nil new-props)))))
            dependent-ids)))

  (defsubst elg:move-date-and-dependents-forward ()
    (interactive)
    (elg::move-date-and-dependents))

  (defsubst elg:move-date-and-dependents-backward ()
    (interactive)
    (elg::move-date-and-dependents 'backward))


#+end_src
** Open org agenda for date at point
#+begin_src emacs-lisp :results silent
(defun elg::open-org-agenda-at-date ()
  (interactive)
  (let ((date (ts-format "%Y-%m-%d" (ts-parse (elg:get-date-at-point)))))
    (org-agenda-list nil date 'day))
  (other-window 1))
#+end_src
** Navigate to org file
#+begin_src emacs-lisp :results silent
(defun elg:navigate-to-org-file ()
  "Navigate to a location in an org file when
supplied with the file name (string) and point (number)."
  (interactive)
  (if-let* ((props (elg::select-entry))
	    (buffer (plist-get props :elg-org-buffer))
	    (marker (plist-get props :begin)))
      (progn 
	(switch-to-buffer-other-window buffer)
	(goto-char marker)
	(outline-show-children)
	(outline-show-entry)
	(beginning-of-line))
    (message "Cannot navigate to org file: no data at point.")))
#+end_src
** with point at org entry
#+begin_src emacs-lisp :results silent
(defmacro elg:with-point-at-orig-entry (props &rest body)
  "Execute BODY with point at location given by the `:begin' property.
Buffer is determined from the `:org-buffer' property. If props is NIL, 
then use the cell at point, prompting the user if necessary.
Otherwise, the values are based on the supplied property list." 
  (declare (indent 2))
  `(let* ((point (plist-get (or ,props ',(elg::select-entry)) :begin))
	  (buffer (plist-get (or ,props ',(elg::select-entry)) :elg-org-buffer)))
     (with-current-buffer buffer
       (save-excursion
	 (goto-char point)
	 ,@body))))
#+end_src
* Insertion functions
#+begin_src emacs-lisp :results silent
  (defun elg::change-char (char)
    "Replace the character at point with CHAR, preserving all 
  existing text properties."
    (let ((props (elg:get-prop-at-point)))
      (delete-char 1)
      (insert char)
      (backward-char)
      (set-text-properties (point) (1+ (point)) `(:elg ,props))))
    

  (defun elg::insert-entry (props)
    (elg::get-header-create (plist-get props :elg-header))
    (forward-char (elg::convert-date-to-column-number (plist-get props :elg-date)))
    (let ((old-props (plist-get (text-properties-at (point)) :elg)))
      (if old-props
          (progn
            (delete-char 1)
            (insert elg-cal-multiple-entry-character)
            (backward-char)
            (set-text-properties (point) (1+ (point)) `(:elg ,(append old-props
                                                                      (list props)))))
        (delete-char 1)
        (insert (elg::get-display-char (plist-get props :elg-type)))
        (backward-char)
        (set-text-properties (point) (1+ (point)) `(:elg ,(list props))))
      (add-text-properties (point) (1+ (point)) '(face (:background "red")))))

  (defun elg::get-header-create (header)
    "Put point at the first char in the HEADER line, creating a new header
  line if one does not exist."
    (goto-char (point-min))
    (let ((new-header (concat (s-truncate elg:header-column-offset header))))
      ;; Concat is necessary for reasons I do not understand. Without it,
      ;; the text properties are not set propertly. 
      (if (search-forward new-header nil t)
          (beginning-of-line)
        (put-text-property 0 (length new-header) 'elg-header header new-header)
        (elg::insert-new-header-line new-header)
        (beginning-of-line))))

  (defun elg::insert-new-header-line (header)
    "Inserts a new header."
    ;; This could probably be put in a `cl-flet' inside `elg::get-header-create'. 
    (goto-char (point-max))
    (insert "\n"
            (substring 
             (concat header (make-string elg:header-column-offset ? ))
             0 elg:header-column-offset))
    (cl-loop for year in (elg::get-years)
             do (if (elg::leap-year-p year)
                    (insert elg:leap-year-blank-line)
                  (insert elg:normal-year-blank-line))))

  (defun elg::draw-month-line ()
    (let ((calendar-line ""))
      (dolist (year (elg::get-years))
        (if (elg::leap-year-p year)
            (setq calendar-line (concat calendar-line 
                                        (replace-regexp-in-string "xxxx" (number-to-string year) 
                                                                  elg:leap-year-month-line)))
          (setq calendar-line (concat calendar-line
                                      (replace-regexp-in-string "xxxx" (number-to-string year) 
                                                                elg:normal-year-month-line)))))
      (insert 
       (concat (make-string elg:header-column-offset ? ) calendar-line))))

  (defun elg::draw-number-line ()
    (let ((number-line ""))
      (dolist (year (elg::get-years))
        (if (elg::leap-year-p year)
            (setq number-line (concat number-line elg:leap-year-date-line))
          (setq number-line (concat number-line elg:normal-year-date-line))))
      (insert 
       (concat (make-string elg:header-column-offset ? ) number-line))))

  (defun elg::draw-horizontal-line ()
    (let* ((length
            (+ (cl-loop for year in elg::date-range
                        sum (if (elg::leap-year-p year)
                                (+ 366 12)
                              (+ 365 12)))
               elg:header-column-offset))
           (string (make-string length ? )))
      (put-text-property 0 length
                         'face
                         'elg:horizontal-line-face
                         string)
      (insert string)))

#+end_src
* User movement functions
** Scrolling
#+begin_src emacs-lisp :results silent
  (defsubst elg-scroll-forward ()
    (interactive)
    (elg-scroll 'forward))

  (defsubst elg-scroll-backward ()
    (interactive)
    (elg-scroll 'backward))

  (defun elg-scroll (direction)
    ;; HACK - This his horrible code. Please fix me. 
    "Place, or move, an overlay on each line, hiding (or showing)
  the month immediately after the headers.

  DIRECTION must be a symbol: `forward' or `backard'."
    (let ((column (current-column))
          (line (line-number-at-pos)))
      (cond ((and (not elg--hidden-overlays)
                  (eq direction 'forward))
             (progn
               (goto-char (point-min))
               (setq elg--hidden-overlays 
                     (cl-loop with num-lines = (count-lines (point-min) (point-max))
                              for line from 1 to num-lines
                              collect (make-overlay (progn (move-to-column (1+ elg:header-column-offset)) (point))
                                                    (elg--next-line))
                              until (= (line-number-at-pos) num-lines)
                              do (next-line)))
               (cl-loop for overlay in elg--hidden-overlays
                        do (overlay-put overlay 'invisible t))))
            (elg--hidden-overlays
             (let ((end (pcase direction
                          (`forward
                           (lambda (overlay)
                             (save-excursion
                               (goto-char (overlay-end overlay))
                               (search-forward "|" (point-at-eol) t))))
                          (`backward
                           (lambda (overlay)
                             (goto-char (overlay-end overlay))
                             (search-backward "|" (point-at-bol) t)
                             (let ((x (search-backward "|" (point-at-bol) t)))
                               (when x
                                 (1+ x))))))))
               (if (funcall end (car elg--hidden-overlays))
                   (cl-loop for overlay in elg--hidden-overlays
                            do (move-overlay overlay
                                             (overlay-start overlay)
                                             (funcall end overlay)))
                 (when (eq direction 'backward)
                   (setq elg--hidden-overlays nil))))))
      (goto-char (point-min))
      (goto-line line)
      (move-to-column column)))



#+end_src
** Move selection bar
#+begin_src emacs-lisp :results silent
(defun elg::move-selection-bar-forward ()
  "Not a selection bar. For now, just the cursor.
Moves to the next filled cell on the line. Does not move to 
next line if it is at the last entry on the line."
  (interactive)
  (when (<= (line-number-at-pos) 2)
    (goto-line 3))
  (when (<= (current-column) elg:header-column-offset)
    (forward-char elg:header-column-offset))
  (when-let ((point (save-excursion 
		      (forward-char 1)
		      (re-search-forward elg:cell-entry-re
					 (point-at-eol)
					 t))))
    (goto-char (1- point))))

(defun elg::move-selection-bar-backward ()
  "Not a selection bar. For now, just the cursor."
  (interactive)
  (when-let ((point (re-search-backward elg:cell-entry-re
					(point-at-bol)
					t)))
    (goto-char point)))

#+end_src
** Misc
#+begin_src emacs-lisp :results silent
(defsubst elg::move-up ()
  (interactive)
  (elg::move-vertically 'up))

(defsubst elg::move-down ()
  (interactive)
  (elg::move-vertically 'down))

(cl-defun elg::move-vertically (up-or-down)
  (if (eq up-or-down 'up)
      (if (> (org-current-line) 3)
	  (previous-line)
	(return-from elg::move-vertically nil))
    (if (< (org-current-line) (count-lines (point-min) (point-max)))
	(next-line)
      (return-from elg::move-vertically nil)))
  (let ((next (save-excursion (re-search-forward elg:cell-entry-re (point-at-eol) t)))
	(previous (save-excursion (re-search-backward elg:cell-entry-re (point-at-bol) t))))
    (cond ((and (not next) (not previous))
	   (elg::move-vertically up-or-down))
	  ((and (not next) previous)
	   (goto-char previous))
	  ((and (not previous) next)
	   (goto-char (1- next)))
	  (t (if (< (- next (point)) (- (point) previous))
		 (goto-char (1- next))
	       (goto-char previous))))))

(defun elg::move-horizontally (n)
  "Ensures that the point is not on a vertical line."
  (forward-char n)
  (when (elg::on-vertical-line)
    (if (< n 0)
	(backward-char)
      (forward-char))))

#+end_src
* Customizing
** create overlay rule 
#+begin_src emacs-lisp :results silent
  (defun elg--run-parsing-functions ()
    (-flatten-n 1
     (cl-loop for (prop . function) in elg--parsing-functions
              collect `(,prop ,(funcall function)))))

  (defun elg--draw-display ()
    (ov-clear)
    (save-excursion
      (goto-char (point-min))
      (while (next-single-property-change (point) :elg)
        (goto-char (next-single-property-change (point) :elg))
        (when (get-text-property (point) :elg)
          (cl-loop for func in elg--display-rules
                   do (funcall func))))))

  (cl-defmacro elg--add-rule (&key name args body parser docstring)
    "NAME is used to name the function or property value.

  ARGS is a list of the properties that will be used by the function. 
  Any poperties supplied here will be automatically fetched from 
  the cell at point and let-bound for use within BODY. Any argument
  listed here may be listed with or without a preceding colon. 

  BODY is the body of the function, which will be spliced into 
  the function being created. BODY should generally do one of the following: 
  change the display character of a cell by using `elg::change-char', laying
  an overlay, or setting text-properties. The return value of BODY is ignored and
   all changes must be made through side-effects. 

  DOCSTRING is the docstring of the newly-defined function.

  PARSER is an optional argument used to add information to cells when the
  calendar is generated. It must be an alist in form of ((property-name . body)).
  You may specify a property-name which begins with a colon, or not. If none is 
  provided, a colon will be added. Body is the body of a function that is called 
  when the point is at the first point of each org heading. Its return value will
  be assigned to the property-name for each cell. 

  After the function is created, it is inserted into the appropriate function list
  to be run either when parsing the org file and storing text properties or run
  when processing the display settings of each individual cell."
    (declare (indent defun))
    (let ((func-name (intern (concat "elg--display-rule-" (symbol-name name)))))
      `(progn
         (when ',parser
           (cl-loop for (prop . val) in (-list ',parser)
                    do (setf (alist-get (if (s-starts-with-p ":" (symbol-name prop))
                                            prop
                                          (intern (concat ":" (symbol-name prop))))
                                        elg--parsing-functions)
                             `(lambda () ,@val))))
         (if (and ',name ',body (or ',parser ',args))
             (cl-pushnew
              (defun ,func-name ()
                ,docstring
                (mapc
                 (lambda (arg-list)
                   (-let ((,(append (cl-loop for arg in args
                                             collect (if (s-starts-with-p ":" (symbol-name arg))
                                                         (intern (substring (symbol-name arg) 1))			
                                                       arg))
                                    (cl-loop for (prop . val) in parser
                                             collect (if (s-starts-with-p ":" (symbol-name prop))
                                                         (intern (substring (symbol-name prop) 1))			
                                                       prop)))
                           arg-list))
                     ,@body))
                 (elg:zip
                  (mapcar #'elg:get-prop-at-point
                          (append ',(cl-loop for arg in args
                                             collect (if (s-starts-with-p ":" (symbol-name arg))
                                                         arg
                                                       (intern (concat ":" (symbol-name arg)))))
                                  ',(cl-loop for (prop . val) in parser
                                             collect (if (s-starts-with-p ":" (symbol-name prop))
                                                         prop
                                                       (intern (concat ":" (symbol-name prop))))))))))
              elg--display-rules)
           (cl-pushnew (defun ,func-name () ,docstring ,@body)
                       elg--display-rules)))))

#+end_src
** User config
#+begin_src emacs-lisp :results silent
  (elg--add-rule
    :name deadsync
    :docstring "asdfasdf"
    :parser ((org-deadsync-active . ((cdr (car (org-entry-properties (point) "ORG-DEADSYNC-ACTIVE")))))
             (org-deadsync-link . ((cdr (car (org-entry-properties (point) "ORG-DEADSYNC-LINK"))))))
    :body ((when (and org-deadsync-active
                      org-deadsync-link)
             (let ((end (point))
                   (start (save-excursion (elg::goto-id org-deadsync-link)
                                          (point))))
               (elg--draw-gradient "red" "blue" start end)))))

  (elg--add-rule
    :name display-char
    :docstring "Display the appropriate character for the cell at point."
    :args (elg-deadline elg-timestamp elg-timestamp-ia elg-scheduled)
    :body ((let ((elg-multi (> (length (elg:get-prop-at-point)) 1)))
             (elg::change-char (cond (elg-multi "☰")
                                     (elg-deadline  "▲")
                                     (elg-timestamp "●")
                                     (elg-timestamp-ia " ")
                                     (elg-scheduled " "))))))


#+end_src
* Parsing
** Parsing function run at point
#+begin_src emacs-lisp :results silent
  (defun elg--parser ()
    (let* ((category (cdr (assoc "CATEGORY" (org-entry-properties (point) "CATEGORY"))))
           ;; For some reason, certain properties retrieved using `org-entry-properties' return
           ;; the `category' of an entry if the value is nil. For example, if there is no timestamp
           ;; in an entry, it will return the category. Thus, certain property values must be check
           ;; against the entry's category to determine whether the value is nil. Since category
           ;; is repeatedly used, it is stored first.
           (prop-list (append
                       (list :elg-category category)
                       (list :elg-root
                             (save-excursion 
                               (while (org-up-heading-safe))
                               (cdar (org-entry-properties (point) "ITEM"))))
                       (list :elg-todo 
                             (cdr (car (org-entry-properties (point) "TODO"))))
                       (list :elg-file 
                             (cdr (car (org-entry-properties (point) "FILE"))))
                       (list :elg-headline
                             (cdar (org-entry-properties (point) "ITEM")))
                       (list :elg-timestamp
                             (when-let ((timestamp (cdar (org-entry-properties (point) "TIMESTAMP"))))
                               (cond ((string= timestamp
                                               category)
                                      nil)
                                     ((s-match "--" timestamp)
                                      nil)
                                     (t
                                      (elg::convert-date-string timestamp)))))
                       (list :elg-timestamp-ia
                             (when-let ((timestamp-ia (cdar (org-entry-properties (point) "TIMESTAMP_IA"))))
                               (cond ((string= timestamp-ia
                                               category)
                                      nil)
                                     ((s-match "--" timestamp-ia)
                                      nil)
                                     (t
                                      (elg::convert-date-string timestamp-ia)))))
                       (list :elg-timestamp-range
                             (when-let ((range (cadr (org-entry-properties (point) "TIMESTAMP"))))
                               (cond ((string= range category)
                                      nil)
                                     ((not (s-match "--" range))
                                      nil)
                                     (t
                                      (let ((dates (s-split "--" range)))
                                        (list (elg::convert-date-string (car dates))
                                              (elg::convert-date-string (cadr dates))))))))
                       (list :elg-timestamp-ia-range
                             (when-let ((range (cadr (org-entry-properties (point) "TIMESTAMP_IA"))))
                               (cond ((string= range category)
                                      nil)
                                     ((not (s-match "--" range))
                                      nil)
                                     (t
                                      (let ((dates (s-split "--" range)))
                                        (list (elg::convert-date-string (car dates))
                                              (elg::convert-date-string (cadr dates))))))))
                       (list :elg-deadline 
                             (when (cdr (car (org-entry-properties (point) "DEADLINE")))
                               (if (string= (cdr (car (org-entry-properties (point) "DEADLINE"))) category)
                                   nil
                                 (elg::convert-date-string (cdr (car (org-entry-properties (point) "DEADLINE")))))))
                       (list :elg-hashtag
                             (when-let* ((tag-string (cdar (org-entry-properties (point) "ALLTAGS")))
                                         (hashtag (-first (lambda (tagstring) (s-starts-with-p "#" tagstring))
                                                          (s-split ":" tag-string))))
                               (org-no-properties hashtag)))
                       (list :elg-scheduled
                             (when (cdr (car (org-entry-properties (point) "SCHEDULED")))
                               (if (string= (cdr (car (org-entry-properties (point) "SCHEDULED"))) category)
                                   nil
                                 (elg::convert-date-string (cdr (car (org-entry-properties (point) "SCHEDULED")))))))
                       (list :elg-alltags
                             (when-let ((tag-string (cdar (org-entry-properties (point) "ALLTAGS"))))
                               (mapcar #'org-no-properties (s-split ":" tag-string t))))
                       (list :elg-header
                             (pcase elg:header-type
                               ('root 
                                (save-excursion 
                                  (while (org-up-heading-safe))
                                  (cdar (org-entry-properties (point) "ITEM"))))
                               ('hashtag 
                                (when-let ((tag-string (cdar (org-entry-properties (point) "ALLTAGS"))))
                                  (substring 
                                   (-first (lambda (tagstring) (s-starts-with-p "#" tagstring))
                                           (s-split ":" tag-string))
                                   1)))
                               ('category  category)
                               (_ (error "Invalid header type."))))
                       (list :elg-org-buffer
                             (current-buffer))
                       (list :elg-dependents
                             (cdar (org-entry-properties (point) "ELG-DEPENDENTS")))
                       (list :elg-anchor
                             (org-entry-get (point) "ELG-ANCHOR"))
                       (list :elg-org-id
                             (org-id-get-create))
                       (list :fuck-you t))))
      (setq prop-list (append 
                       (cond ((plist-get prop-list :elg-deadline)
                              (list :elg-date (plist-get prop-list :elg-deadline)
                                    :elg-type 'deadline
                                    :elg-display-char (org-no-properties (elg::get-display-char 'deadline))))
                             ;;'display (org-no-properties (elg::get-display-char 'deadline))))
                             ((plist-get prop-list :elg-timestamp)
                              (list :elg-date (plist-get prop-list :elg-timestamp)
                                    :elg-type 'timestamp
                                    :elg-display-char (org-no-properties (elg::get-display-char 'timestamp))))
                             ;;'display (org-no-properties (elg::get-display-char 'timestamp))))
                             ((plist-get prop-list :elg-timestamp-ia)
                              (list :elg-date (plist-get prop-list :elg-timestamp-ia)
                                    :elg-type 'timestamp-ia
                                    :elg-display-char (org-no-properties (elg::get-display-char 'timestamp-ia))))
                             ;;'display (org-no-properties (elg::get-display-char 'timestamp-ia))))
                             ((plist-get prop-list :elg-scheduled)
                              (list :elg-date (plist-get prop-list :elg-scheduled)
                                    :elg-type 'scheduled
                                    :elg-display-char (org-no-properties (elg::get-display-char 'scheduled)))))
                       ;;'display (org-no-properties (elg::get-display-char 'scheduled)))))
                       (list :elg-anchor-date
                             (when-let ((anchor-id (plist-get prop-list :elg-anchor))
                                        (id-point (cdr (org-id-find anchor-id))))
                               (save-excursion 
                                 (goto-char id-point)
                                 (plist-get (elg--parser) :elg-date))))
                       (cadr (org-element-at-point))
                       (elg--run-parsing-functions)
                       prop-list))
      ;; only return those that have a date property 
      (when (plist-get prop-list :elg-date)
        prop-list)))
#+end_src
** Parsing loop 
Should this handle archiving (in org-map-entries) and timestamp (in org-ql) differently? 
#+begin_src emacs-lisp :results silent
(defun elg--iterate ()
  "Iterate over all entries."
  ;; org-ql is much faster than org-map-entries.
  (if (fboundp 'org-ql-select)
      (mapc #'elg::insert-entry
	    (-non-nil
	     (org-ql-select elg:agenda-files
	       '(ts) ;;this should be a variable, because sometimes you'll only want deadlines, etc. 
	       :action #'elg--parser)))
    (mapc #'elg::insert-entry
	  (-non-nil
	   (org-map-entries #'elg--parser
			    nil
			    (-list elg:agenda-files)
			    'archive)))))
#+end_src
* Display
** Echo message
#+begin_src emacs-lisp :results silent
(defun elg::show-echo-message ()
  "Show information about the cell at point."
  (interactive)
  (unless (elg::on-vertical-line)
    (message "%s -- %s // %s"
	     (elg:get-date-at-point)
	     (elg:get-header-at-point)
	     (when-let ((headlines (elg:get-prop-at-point :elg-headline)))
	       (substring 
		(cl-loop for headline in headlines
			 concat (concat  headline " // "))
		0
		-3)))))
#+end_src
** Drawing overlays
*** Overlay drawing utilities
**** Set face at point
#+begin_src emacs-lisp :results silent
(defun elg::set-face-at-point (face)
  (ov (point) (1+ (point)) 'face face 'elg-ov t))
#+end_src
**** Color conversion utilities
#+begin_src emacs-lisp :results silent
  (defun elg--color-rgb-to-hex (color)
    "Convert an RBG tuple '(R G B) to six digit hex string \"#RRGGBB\""
    (pcase-let ((`(,r ,g ,b) color))
      (color-rgb-to-hex r g b 2)))

  (defun elg--color-name-to-hex (color)
    "Convert named color to six digit hex color."

    (eval `(color-rgb-to-hex ,@(color-name-to-rgb color) 2)))



  (defalias 'elg--color-name-to-rgb #'color-name-to-rgb)

  (defun elg--color-hex-to-rgb (hex-color)
    "Convert hex color to RGB tuple."
    `(,(string-to-number (substring hex-color 1 3) 16)
      ,(string-to-number (substring hex-color 3 5) 16)
      ,(string-to-number (substring hex-color 5 7) 16)))

  (defun elg--color-to-rgb (color)
    "Convert a color name or hex color to RGB tuple."
    (pcase color
      ;; If it's hex...
      ((and (pred stringp)
            (pred (s-starts-with-p "#")))
       (elg--color-hex-to-rgb color))
      ;; If it's a string (trust the user that the color
      ;; name is in `list-colors-display')...
      ((pred stringp)
       (elg--color-name-to-rgb color))
      ;; If it's already an RGB tuple...
      ((and `(,r ,g ,b)
            (guard (numberp r))
            (guard (numberp g))
            (guard (numberp b)))
       color)
      ;; Otherwise...
      (_ (error "Color type must be hex, e.g., \"#ffccaa\" or color name, e.g., \"red\" or an RGB tuple, e.g., '(1.0 .5 0)"))))
#+end_src
**** Gradients
#+begin_src emacs-lisp :results silent
  (defun elg--get-color-midpoint (color1 color2)
    "Take two colors (any format) and return their
  average as an RGB tuple."
    (let ((color1 (elg--color-to-rgb color1))
          (color2 (elg--color-to-rgb color2)))
      (-zip-with (lambda (c1 c2)
                   (/ (+ c1 c2) 2))
                 color1 color2)))

  (defun elg--draw-two-color-block (start-color end-color start end divider)
    (let ((start-color (elg--color-name-to-hex start-color))
          (end-color (elg--color-name-to-hex end-color)))
      (save-excursion
        (goto-char start)
        (cl-loop for x from start to end
                 do (goto-char x)
                 (ov (point)
                     (1+ (point))
                     'face
                     (if (<= (point) divider)
                         `(:background ,start-color)
                       `(:background ,end-color)))
                 (forward-char)))))	;

  (defun elg--draw-gradient (start-color end-color start end &optional mid-point)
    (let ((color-gradient
           (let ((start-color (elg--color-to-rgb start-color))
                 (end-color (elg--color-to-rgb end-color)))
             (if mid-point
                 (let ((mid-color (elg--get-color-midpoint start-color
                                                           end-color)))
                   (append (color-gradient
                            start-color
                            mid-color
                            (1+ (- mid-point start))
                            (color-gradient mid-color
                                            end-color
                                            (- steps mid-point)))))
               (color-gradient start-color
                               end-color
                               (1+ (- end start)))))))
      (save-excursion
        (goto-char start)
        (mapc (lambda (color)
                (ov (point)
                    (1+ (point))
                    'face
                    `(:background ,(elg--color-rgb-to-hex color)))
                (forward-char))
              color-gradient))))

#+end_src
*** Highlight dependents
#+begin_src emacs-lisp :results silent
  (defsubst elg::highlight-dependents ()
    (interactive)
    (elg::highlight-dependent-dates '(:background "gray")))

  (defun elg::highlight-dependent-dates (face &optional props)
    "Apply FACE to all dependant dates of the current date at point."
    (save-excursion 
      (if-let ((dependents (elg::get-dependents props)))
          (progn (elg::set-face-at-point face)
                 (mapc (lambda (dependent-id)
                         (elg::goto-id dependent-id)
                         (elg::set-face-at-point face))
                       dependents))
        (elg::clear-elg-overlays))))


  ;; (defun elg::highlight-dependent-dates (face)
  ;;   "Apply FACE to all dependant dates of the current date at point."
  ;;   (save-excursion 
  ;;     (if-let ((dependents (elg::get-dependents 'all)))
  ;; 	(progn (elg::set-face-at-point face)
  ;; 	       (mapc (lambda (dependent-id)
  ;; 		       (elg::goto-id dependent-id)
  ;; 		       (elg::set-face-at-point face))
  ;; 		     dependents))
  ;;       (elg::clear-elg-overlays))))

#+end_src
*** Draw overlays according to rules
**** TODO make a "matches any value" place holder 
#+begin_src emacs-lisp :results silent 
  ;; (defun elg--draw-overlays ()
  ;;   "Draw all overlays in the buffer based on underlying text properties."
  ;;   (cl-loop for points being the intervals of (current-buffer)
  ;;            do (cl-loop for (key . value) in elg--overlay-rules
  ;;                        do (when-let ((val (lax-plist-get (text-properties-at (car points)) key))
  ;;                                      (effects (alist-get val (alist-get key elg--overlay-rules) nil nil #'equal)))
  ;;                             (pcase effects
  ;;                               ((pred functionp)
  ;;                                ;; Odds are that the function will apply an overlay...
  ;;                                (let ((overlay (funcall effects (car points) (cdr points))))
  ;;                                  ;; ...if it does, also provide a name so we can find it later.
  ;;                                  (when (ov-p overlay)
  ;;                                    (ov-set overlay key t))))
  ;;                               ;; If it's not a function, then assume the rule
  ;;                               ;; is a list of properties for an overlay. Add
  ;;                               ;; an overlay with those properties, as well as
  ;;                               ;; a name for the overlay `:elg-NAME'
  ;;                               (_ (ov (car points) (cdr points)
  ;;                                      (-flatten-n 1
  ;;                                                  (list effects
  ;;                                                        key t)))))))))


  ;; (defun elg--draw-overlays* ()
  ;;   "Draw all overlays in the buffer based on underlying text properties."
  ;;   (cl-loop for points being the intervals of (current-buffer)
  ;;            do (cl-loop for (name . value) in elg--overlay-rules
  ;;                        do (when-let ((val (lax-plist-get (text-properties-at (car points)) key))
  ;;                                      (effects (alist-get val (alist-get key elg--overlay-rules) nil nil #'equal)))
  ;;                             (pcase effects
  ;;                               ((pred functionp)
  ;;                                ;; Odds are that the function will apply an overlay...
  ;;                                (let ((overlay (funcall effects (car points) (cdr points))))
  ;;                                  ;; ...if it does, also provide a name so we can find it later.
  ;;                                  (when (ov-p overlay)
  ;;                                    (ov-set overlay key t))))
  ;;                               ;; If it's not a function, then assume the rule
  ;;                               ;; is a list of properties for an overlay. Add
  ;;                               ;; an overlay with those properties, as well as
  ;;                               ;; a name for the overlay `:elg-NAME'
  ;;                               (_ (ov (car points) (cdr points)
  ;;                                      (-flatten-n 1
  ;;                                                  (list effects
  ;;                                                        key t)))))))))
#+end_src
* Major mode
#+begin_src emacs-lisp :results silent
  (setq elg-mode-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "x")   #'elg-interact-mode)
          (define-key map (kbd "r")   #'elg:open)
          (define-key map (kbd "SPC") #'elg:navigate-to-org-file)
          (define-key map (kbd "p")   #'elg::move-up)
          (define-key map (kbd "n")   #'elg::move-down)
          (define-key map (kbd "f")   #'elg::move-selection-bar-forward)
          (define-key map (kbd "F")   #'elg-scroll-forward)
          (define-key map (kbd "B")   #'elg-scroll-backward)
          (define-key map (kbd "b")   #'elg::move-selection-bar-backward)
          (define-key map (kbd "RET") #'elg::open-org-agenda-at-date)
          (define-key map (kbd "M-f") #'elg::shift-date-forward)
          (define-key map (kbd "M-b") #'elg::shift-date-backward)
          (define-key map (kbd "C-M-f") #'elg:move-date-and-dependents-forward)
          (define-key map (kbd "C-M-b") #'elg:move-date-and-dependents-backward)
          map))

  (define-derived-mode elg-mode special-mode "El Gantt" "Horizontal calendar interface for orgmode. \{keymap}")
#+end_src

* Open function 
#+begin_src emacs-lisp :results silent
  (defun elg:open ()
    (interactive)
    (switch-to-buffer "*El Gantt Calendar*")
    (setq elg::date-range (elg::get-years))
    (setq elg--hidden-overlays nil)
    (erase-buffer)
    (elg::draw-month-line)
    (insert "\n")
    (elg::draw-number-line)
    ;;  (elg::draw-horizontal-line)
    (elg--iterate)
    (elg-mode)
    (read-only-mode -1)
    (toggle-truncate-lines 1)
    (horizontal-scroll-bar-mode 1)
    (elg--draw-display)
    (goto-char (point-min))
    ;;  (forward-char (elg::convert-date-to-column-number (format-time-string "%Y-%m-%d")))
    ;;(add-hook 'post-command-hook #'elg::show-echo-message nil t)
    ;;(add-hook 'post-command-hook #'elg::highlight-dependents nil t)

    ;;(add-hook 'post-command-hook 'elg::vertical-highlight nil t)
    ;;(delete-other-windows))
)
#+end_src
* Testing
** Get data
#+begin_src emacs-lisp :results silent
  (defun elg:get-data ()
    "Testing function." 
    (-non-nil
     (org-map-entries #'elg--parser
                      nil
                      (-list elg:agenda-files)
                      elg:skip-files)))

  (defun elg:get-data-org-ql ()
    "Testing function."
    (-non-nil
     (org-ql-select elg:agenda-files
       '(ts)
       :action #'elg--parser)))

#+end_src
* Recycling
** plist pair match
#+begin_src emacs-lisp :results silent
(defun elg::plist-pair-p (plist key val &optional equal)
  "Return t if PLIST has KEY and VAL pair. Tests using `equal'.
Optional EQUAL provides a function which performs equality test
and returns T or nil."
  (when-let ((stored-val (plist-get plist key)))
    (cond ((not predicate)
	   (or (equal stored-val val)))
	  ((functionp predicate)
	   (funcall predicate stored-val val)))))
#+end_src
** setting faces 
#+begin_src emacs-lisp :results silent
(defun elg::set-face (face begin &optional end)
  "Puts an overlay with FACE at point, and set the overlay property `elg-ov'
to t. FACE can be any value accepted by the 'face overlay property. BEGIN
is the start point. END is the end. It is not provided, then the face is 
applied to the character at point only."
  (ov (or begin (point)) (or end (1+ (point))) 'face face
      'elg-ov t))

(defun elg::clear-elg-overlays ()
  "Clear all overlays with `elg-ov' set to t."
  (ov-clear 'elg-ov t))
#+end_src

